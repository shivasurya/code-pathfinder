package diagnostic

// FunctionMetadata contains all information about a function needed for diagnostic analysis.
type FunctionMetadata struct {
	// FilePath is the relative path to the source file
	// Example: "myapp/views.py"
	FilePath string

	// FunctionName is the simple function name
	// Example: "process_input"
	FunctionName string

	// FQN is the fully qualified name (module.Class.function)
	// Example: "myapp.views.process_input" or "myapp.models.User.save"
	FQN string

	// StartLine is the first line of the function definition (1-indexed)
	// Includes decorators if present
	StartLine int

	// EndLine is the last line of the function body (1-indexed)
	EndLine int

	// SourceCode is the complete function source code
	// Includes decorators, signature, and body
	SourceCode string

	// LOC is lines of code (EndLine - StartLine + 1)
	LOC int

	// HasDecorators indicates if function has decorators (@property, @classmethod, etc.)
	HasDecorators bool

	// ClassName is the containing class name (if method), empty if top-level function
	// Example: "User" for myapp.models.User.save
	ClassName string

	// IsMethod indicates if this is a class method (has self/cls parameter)
	IsMethod bool

	// IsAsync indicates if this is an async function
	IsAsync bool
}

// LLMAnalysisResult contains the LLM's analysis of a function.
//
//nolint:tagliatelle // LLM API uses snake_case JSON tags
type LLMAnalysisResult struct {
	// FunctionFQN identifies which function was analyzed
	FunctionFQN string `json:"function_fqn,omitempty"`

	// DiscoveredPatterns contains sources/sinks/sanitizers found by LLM
	DiscoveredPatterns DiscoveredPatterns `json:"discovered_patterns"`

	// DataflowTestCases are test cases generated by LLM
	// Each test case specifies expected dataflow behavior
	DataflowTestCases []DataflowTestCase `json:"dataflow_test_cases"`

	// VariableTracking shows how LLM traced variables through the function
	VariableTracking []VariableTrack `json:"variable_tracking"`

	// Metadata about the analysis
	AnalysisMetadata AnalysisMetadata `json:"analysis_metadata"`
}

// DiscoveredPatterns contains all patterns discovered by LLM in the function.
type DiscoveredPatterns struct {
	Sources     []PatternLocation      `json:"sources"`
	Sinks       []PatternLocation      `json:"sinks"`
	Sanitizers  []PatternLocation      `json:"sanitizers"`
	Propagators []PropagatorOperation  `json:"propagators"`
}

// PatternLocation describes where a pattern (source/sink/sanitizer) was found.
type PatternLocation struct {
	// Pattern is the code pattern (e.g., "request.GET", "os.system")
	Pattern string `json:"pattern"`

	// Lines where this pattern appears
	Lines []int `json:"lines"`

	// Variables involved
	Variables []string `json:"variables"`

	// Category for semantic grouping
	// Examples: "user_input", "file_read", "sql_execution", "command_exec"
	Category string `json:"category"`

	// Description of what this pattern does
	Description string `json:"description"`

	// Severity (for sinks): CRITICAL, HIGH, MEDIUM, LOW
	Severity string `json:"severity,omitempty"`
}

// PropagatorOperation describes how data propagates.
//
//nolint:tagliatelle // LLM API uses snake_case JSON tags
type PropagatorOperation struct {
	// Type: "assignment", "function_call", "return"
	Type string `json:"type"`

	// Line number
	Line int `json:"line"`

	// Source variable
	FromVar string `json:"from_var"`

	// Destination variable
	ToVar string `json:"to_var"`

	// Function name (if Type == "function_call")
	Function string `json:"function,omitempty"`
}

// DataflowTestCase is a test case generated by LLM.
// This is what we validate our tool against.
//
//nolint:tagliatelle // LLM API uses snake_case JSON tags
type DataflowTestCase struct{
	// TestID for reference
	TestID int `json:"test_id"`

	// Description of what this test validates
	Description string `json:"description"`

	// Source information
	Source TestCaseSource `json:"source"`

	// Sink information
	Sink TestCaseSink `json:"sink"`

	// Flow path (sequence of variables/operations)
	FlowPath []FlowStep `json:"flow_path"`

	// Sanitizers in the path (if any)
	SanitizersInPath []string `json:"sanitizers_in_path"`

	// Expected detection result
	// true: Our tool SHOULD detect this flow
	// false: Our tool should NOT detect (e.g., sanitized)
	ExpectedDetection bool `json:"expected_detection"`

	// Vulnerability type (if ExpectedDetection == true)
	VulnerabilityType string `json:"vulnerability_type"`

	// Confidence score (0.0-1.0)
	Confidence float64 `json:"confidence"`

	// Reasoning for this test case
	Reasoning string `json:"reasoning"`

	// Failure category (if tool might miss this)
	// Categories: control_flow_branch, field_sensitivity, sanitizer_missed,
	//            container_operation, string_formatting, method_call_propagation,
	//            assignment_chain, return_flow, parameter_flow, complex_expression,
	//            context_required, none
	FailureCategory string `json:"failure_category,omitempty"`
}

// TestCaseSource describes the source in a test case.
type TestCaseSource struct {
	Pattern  string `json:"pattern"` // e.g., "request.GET['cmd']"
	Line     int    `json:"line"`
	Variable string `json:"variable"`
}

// TestCaseSink describes the sink in a test case.
type TestCaseSink struct {
	Pattern  string `json:"pattern"` // e.g., "os.system"
	Line     int    `json:"line"`
	Variable string `json:"variable"`
}

// FlowStep describes one step in a dataflow path.
type FlowStep struct {
	Line      int    `json:"line"`
	Variable  string `json:"variable"`
	Operation string `json:"operation"` // "source", "assignment", "call", "sanitizer", "sink"
}

// VariableTrack shows how LLM traced a variable.
//
//nolint:tagliatelle // LLM API uses snake_case JSON tags
type VariableTrack struct {
	Variable      string   `json:"variable"`
	FirstDefined  int      `json:"first_defined"`
	LastUsed      int      `json:"last_used"`
	Aliases       []string `json:"aliases"` // Other variable names that hold the same data
	FlowsToLines  []int    `json:"flows_to_lines"`
	FlowsToVars   []string `json:"flows_to_vars"`
}

// AnalysisMetadata contains metadata about the LLM analysis.
//
//nolint:tagliatelle // LLM API uses snake_case JSON tags
type AnalysisMetadata struct {
	TotalSources    int      `json:"total_sources"`
	TotalSinks      int      `json:"total_sinks"`
	TotalSanitizers int      `json:"total_sanitizers"`
	TotalFlows      int      `json:"total_flows"`
	DangerousFlows  int      `json:"dangerous_flows"`
	SafeFlows       int      `json:"safe_flows"`
	Confidence      float64  `json:"confidence"`
	Limitations     []string `json:"limitations"`
	ProcessingTime  string   `json:"processing_time,omitempty"`
	ModelUsed       string   `json:"model_used,omitempty"`
}
