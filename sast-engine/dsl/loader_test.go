package dsl

import (
	"encoding/json"
	"os"
	"path/filepath"
	"testing"

	"github.com/shivasurya/code-pathfinder/sast-engine/graph/callgraph/core"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestRuleLoader_New(t *testing.T) {
	loader := NewRuleLoader("test_rules.py")
	assert.NotNil(t, loader)
	assert.Equal(t, "test_rules.py", loader.RulesPath)
}

func TestRuleLoader_LoadRules(t *testing.T) {
	t.Run("loads valid Python DSL rules", func(t *testing.T) {
		// Create test rules file
		// Note: Rules auto-execute when run as __main__ (no manual __main__ block needed)
		rulesContent := `from codepathfinder import rule, calls

@rule(id="test-eval", severity="high", cwe="CWE-94")
def detect_eval():
    """Test rule."""
    return calls("eval")
`
		tmpFile := createTempPythonFile(t, rulesContent)
		defer os.Remove(tmpFile)

		loader := NewRuleLoader(tmpFile)
		rules, err := loader.LoadRules(nil)

		require.NoError(t, err)
		assert.Len(t, rules, 1)
		assert.Equal(t, "test-eval", rules[0].Rule.ID)
		assert.Equal(t, "high", rules[0].Rule.Severity)
		assert.Equal(t, "CWE-94", rules[0].Rule.CWE)
	})

	t.Run("rejects file without rule decorators", func(t *testing.T) {
		// Normal Python file without @rule decorator
		appContent := `def main():
    print("Hello world")

if __name__ == "__main__":
    main()
`
		tmpFile := createTempPythonFile(t, appContent)
		defer os.Remove(tmpFile)

		loader := NewRuleLoader(tmpFile)
		_, err := loader.LoadRules(nil)

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "file does not contain code analysis rules")
		assert.Contains(t, err.Error(), "no @rule decorator or codepathfinder imports found")
	})

	t.Run("skips files without rule decorators in directory", func(t *testing.T) {
		tmpDir := t.TempDir()

		// Create valid rule file
		validRule := `from codepathfinder import rule, calls

@rule(id="test-rule", severity="high", cwe="")
def test():
    return calls("eval")
`
		err := os.WriteFile(filepath.Join(tmpDir, "valid_rule.py"), []byte(validRule), 0644)
		require.NoError(t, err)

		// Create normal app file (should be skipped)
		appFile := `def main():
    print("Hello")
`
		err = os.WriteFile(filepath.Join(tmpDir, "app.py"), []byte(appFile), 0644)
		require.NoError(t, err)

		loader := NewRuleLoader(tmpDir)
		rules, err := loader.LoadRules(nil)

		require.NoError(t, err)
		// Should only load the valid rule, not the app.py
		assert.Len(t, rules, 1)
		assert.Equal(t, "test-rule", rules[0].Rule.ID)
	})

	t.Run("handles invalid Python syntax", func(t *testing.T) {
		// Include decorator so it passes early filtering
		rulesContent := `from codepathfinder import rule
this is not valid python`
		tmpFile := createTempPythonFile(t, rulesContent)
		defer os.Remove(tmpFile)

		loader := NewRuleLoader(tmpFile)
		_, err := loader.LoadRules(nil)

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to execute Python rules")
	})

	t.Run("handles invalid JSON output", func(t *testing.T) {
		// Include decorator so it passes early filtering
		rulesContent := `from codepathfinder import rule
print("not json")`
		tmpFile := createTempPythonFile(t, rulesContent)
		defer os.Remove(tmpFile)

		loader := NewRuleLoader(tmpFile)
		_, err := loader.LoadRules(nil)

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to parse rule JSON IR")
	})

	t.Run("handles non-existent file", func(t *testing.T) {
		loader := NewRuleLoader("/nonexistent/file.py")
		_, err := loader.LoadRules(nil)

		assert.Error(t, err)
	})
}

func TestRuleLoader_ExecuteRule(t *testing.T) {
	cg := core.NewCallGraph()
	cg.CallSites["test.main"] = []core.CallSite{
		{
			Target:   "eval",
			Location: core.Location{File: "test.py", Line: 10},
		},
		{
			Target:   "exec",
			Location: core.Location{File: "test.py", Line: 15},
		},
	}

	t.Run("executes call_matcher rule", func(t *testing.T) {
		rule := &RuleIR{
			Matcher: map[string]interface{}{
				"type":     "call_matcher",
				"patterns": []interface{}{"eval"},
				"wildcard": false,
			},
		}

		loader := NewRuleLoader("")
		detections, err := loader.ExecuteRule(rule, cg)

		require.NoError(t, err)
		assert.Len(t, detections, 1)
		assert.Equal(t, "eval", detections[0].SinkCall)
		assert.Equal(t, 10, detections[0].SinkLine)
	})

	t.Run("executes dataflow rule", func(t *testing.T) {
		rule := &RuleIR{
			Matcher: map[string]interface{}{
				"type": "dataflow",
				"sources": []interface{}{
					map[string]interface{}{
						"patterns": []interface{}{"request.GET"},
						"wildcard": false,
					},
				},
				"sinks": []interface{}{
					map[string]interface{}{
						"patterns": []interface{}{"eval"},
						"wildcard": false,
					},
				},
				"sanitizers": []interface{}{},
				"propagation": []interface{}{},
				"scope":       "local",
			},
		}

		loader := NewRuleLoader("")
		detections, err := loader.ExecuteRule(rule, cg)

		require.NoError(t, err)
		assert.NotNil(t, detections)
	})

	t.Run("executes variable_matcher rule", func(t *testing.T) {
		cg2 := core.NewCallGraph()
		cg2.CallSites["test.func"] = []core.CallSite{
			{
				Target: "process",
				Arguments: []core.Argument{
					{Value: "user_input", IsVariable: true, Position: 0},
				},
				Location: core.Location{Line: 20},
			},
		}

		rule := &RuleIR{
			Matcher: map[string]interface{}{
				"type":     "variable_matcher",
				"pattern":  "user_input",
				"wildcard": false,
			},
		}

		loader := NewRuleLoader("")
		detections, err := loader.ExecuteRule(rule, cg2)

		require.NoError(t, err)
		assert.Len(t, detections, 1)
		assert.Equal(t, "user_input", detections[0].TaintedVar)
	})

	t.Run("handles invalid matcher type", func(t *testing.T) {
		rule := &RuleIR{
			Matcher: map[string]interface{}{
				"type": "invalid_type",
			},
		}

		loader := NewRuleLoader("")
		_, err := loader.ExecuteRule(rule, cg)

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "unknown matcher type")
	})

	t.Run("handles missing matcher type", func(t *testing.T) {
		rule := &RuleIR{
			Matcher: map[string]interface{}{
				"no_type_field": "value",
			},
		}

		loader := NewRuleLoader("")
		_, err := loader.ExecuteRule(rule, cg)

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "matcher type not found")
	})

	t.Run("handles non-map matcher", func(t *testing.T) {
		rule := &RuleIR{
			Matcher: "not a map",
		}

		loader := NewRuleLoader("")
		_, err := loader.ExecuteRule(rule, cg)

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "matcher is not a map")
	})
}

func TestRuleLoader_ExecuteLogic(t *testing.T) {
	t.Run("logic operators return empty for now", func(t *testing.T) {
		cg := core.NewCallGraph()
		loader := NewRuleLoader("")

		rule := &RuleIR{
			Matcher: map[string]interface{}{
				"type": "logic_and",
			},
		}

		detections, err := loader.ExecuteRule(rule, cg)

		require.NoError(t, err)
		assert.Empty(t, detections)
	})
}

func TestRuleLoader_LoadContainerRules(t *testing.T) {
	t.Run("loads container rules from single file", func(t *testing.T) {
		// Create test container rule file
		// NOTE: Rule files should NOT have if __name__ == "__main__" blocks
		// The loader's wrapper script handles compilation via container_ir.compile_all_rules()
		rulesContent := `from rules.container_decorators import dockerfile_rule
from rules.container_matchers import missing

@dockerfile_rule(
    id="TEST-001",
    name="Test Rule",
    severity="HIGH",
    cwe="CWE-250",
    category="security",
    message="Test message"
)
def test_rule():
    return missing(instruction="USER")
`
		tmpFile := createTempPythonFile(t, rulesContent)
		defer os.Remove(tmpFile)

		loader := NewRuleLoader(tmpFile)
		jsonData, err := loader.LoadContainerRules(nil)

		require.NoError(t, err)
		assert.NotEmpty(t, jsonData)

		// Verify it's valid JSON
		var result map[string]interface{}
		err = json.Unmarshal(jsonData, &result)
		require.NoError(t, err)
		assert.Contains(t, result, "dockerfile")
		assert.Contains(t, result, "compose")
	})

	t.Run("loads container rules from directory", func(t *testing.T) {
		tmpDir := t.TempDir()

		// Create multiple rule files
		// NOTE: Rule files should NOT have if __name__ == "__main__" blocks
		rule1 := `from rules.container_decorators import dockerfile_rule
from rules.container_matchers import missing

@dockerfile_rule(id="RULE-1", name="Rule 1", severity="HIGH", cwe="", category="security", message="msg")
def rule1():
    return missing(instruction="USER")
`

		rule2 := `from rules.container_decorators import compose_rule
from rules.container_matchers import service_has

@compose_rule(id="RULE-2", name="Rule 2", severity="CRITICAL", cwe="", category="security", message="msg")
def rule2():
    return service_has(key="privileged", equals=True)
`

		err := os.WriteFile(filepath.Join(tmpDir, "rule1.py"), []byte(rule1), 0644)
		require.NoError(t, err)
		err = os.WriteFile(filepath.Join(tmpDir, "rule2.py"), []byte(rule2), 0644)
		require.NoError(t, err)

		loader := NewRuleLoader(tmpDir)
		jsonData, err := loader.LoadContainerRules(nil)

		require.NoError(t, err)
		assert.NotEmpty(t, jsonData)
	})

	t.Run("handles nonexistent path", func(t *testing.T) {
		loader := NewRuleLoader("/nonexistent/path")
		_, err := loader.LoadContainerRules(nil)

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to access rules path")
	})

	t.Run("handles invalid Python in container rules", func(t *testing.T) {
		rulesContent := `this is not valid python`
		tmpFile := createTempPythonFile(t, rulesContent)
		defer os.Remove(tmpFile)

		loader := NewRuleLoader(tmpFile)
		_, err := loader.LoadContainerRules(nil)

		assert.Error(t, err)
	})

	t.Run("returns error for empty directory", func(t *testing.T) {
		tmpDir := t.TempDir()

		loader := NewRuleLoader(tmpDir)
		_, err := loader.LoadContainerRules(nil)

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "no container rules detected")
	})

	t.Run("returns error for directory without container rule decorators", func(t *testing.T) {
		tmpDir := t.TempDir()

		// Create Python file without container rule decorators (code analysis rule)
		rulesContent := `from codepathfinder import rule, calls

@rule(id="test-eval", severity="high", cwe="CWE-94")
def detect_eval():
    """Test rule."""
    return calls("eval")
`
		err := os.WriteFile(filepath.Join(tmpDir, "code_rule.py"), []byte(rulesContent), 0644)
		require.NoError(t, err)

		loader := NewRuleLoader(tmpDir)
		_, err = loader.LoadContainerRules(nil)

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "no container rules detected")
		assert.Contains(t, err.Error(), "no @dockerfile_rule or @compose_rule decorators found")
	})

	t.Run("returns error for file without container rule decorators", func(t *testing.T) {
		rulesContent := `from codepathfinder import rule, calls

@rule(id="test-eval", severity="high", cwe="CWE-94")
def detect_eval():
    """Test rule."""
    return calls("eval")
`
		tmpFile := createTempPythonFile(t, rulesContent)
		defer os.Remove(tmpFile)

		loader := NewRuleLoader(tmpFile)
		_, err := loader.LoadContainerRules(nil)

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "no container rules detected")
	})
}

func TestRuleLoader_LoadRulesFromFile_ContainerFormat(t *testing.T) {
	t.Run("rejects container rule format in LoadRules", func(t *testing.T) {
		// Create a file that outputs container format (not code analysis format)
		// This should be rejected by LoadRules since it doesn't have @rule decorator
		rulesContent := `if __name__ == "__main__":
    import json
    print(json.dumps({"dockerfile": [], "compose": []}))
`
		tmpFile := createTempPythonFile(t, rulesContent)
		defer os.Remove(tmpFile)

		loader := NewRuleLoader(tmpFile)
		_, err := loader.LoadRules(nil)

		// Should error because it doesn't have @rule decorator
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "file does not contain code analysis rules")
	})
}

func TestIsSandboxEnabled(t *testing.T) {
	t.Run("returns false when env var not set", func(t *testing.T) {
		os.Unsetenv("PATHFINDER_SANDBOX_ENABLED")
		assert.False(t, isSandboxEnabled())
	})

	t.Run("returns true when env var is true", func(t *testing.T) {
		os.Setenv("PATHFINDER_SANDBOX_ENABLED", "true")
		defer os.Unsetenv("PATHFINDER_SANDBOX_ENABLED")
		assert.True(t, isSandboxEnabled())
	})

	t.Run("returns true when env var is TRUE", func(t *testing.T) {
		os.Setenv("PATHFINDER_SANDBOX_ENABLED", "TRUE")
		defer os.Unsetenv("PATHFINDER_SANDBOX_ENABLED")
		assert.True(t, isSandboxEnabled())
	})

	t.Run("returns false when env var is false", func(t *testing.T) {
		os.Setenv("PATHFINDER_SANDBOX_ENABLED", "false")
		defer os.Unsetenv("PATHFINDER_SANDBOX_ENABLED")
		assert.False(t, isSandboxEnabled())
	})

	t.Run("returns false when env var is empty", func(t *testing.T) {
		os.Setenv("PATHFINDER_SANDBOX_ENABLED", "")
		defer os.Unsetenv("PATHFINDER_SANDBOX_ENABLED")
		assert.False(t, isSandboxEnabled())
	})
}

// Helper: Create temporary Python file for testing.
func createTempPythonFile(t *testing.T, content string) string {
	t.Helper()

	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test_rules.py")

	err := os.WriteFile(tmpFile, []byte(content), 0644)
	require.NoError(t, err)

	return tmpFile
}
