
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mcp: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/shivasurya/code-pathfinder/sast-engine/mcp/analytics.go (100.0%)</option>
				
				<option value="file1">github.com/shivasurya/code-pathfinder/sast-engine/mcp/errors.go (100.0%)</option>
				
				<option value="file2">github.com/shivasurya/code-pathfinder/sast-engine/mcp/http.go (99.2%)</option>
				
				<option value="file3">github.com/shivasurya/code-pathfinder/sast-engine/mcp/instance_tools.go (93.9%)</option>
				
				<option value="file4">github.com/shivasurya/code-pathfinder/sast-engine/mcp/pagination.go (100.0%)</option>
				
				<option value="file5">github.com/shivasurya/code-pathfinder/sast-engine/mcp/query_resolver.go (100.0%)</option>
				
				<option value="file6">github.com/shivasurya/code-pathfinder/sast-engine/mcp/server.go (70.8%)</option>
				
				<option value="file7">github.com/shivasurya/code-pathfinder/sast-engine/mcp/status.go (100.0%)</option>
				
				<option value="file8">github.com/shivasurya/code-pathfinder/sast-engine/mcp/tools.go (97.9%)</option>
				
				<option value="file9">github.com/shivasurya/code-pathfinder/sast-engine/mcp/types.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package mcp

import (
        "runtime"
        "time"

        "github.com/shivasurya/code-pathfinder/sast-engine/analytics"
)

// Analytics provides MCP-specific telemetry helpers.
// All events are anonymous and contain no PII.
type Analytics struct {
        transport string // "stdio" or "http"
        startTime time.Time
}

// NewAnalytics creates a new analytics instance.
func NewAnalytics(transport string) *Analytics <span class="cov8" title="1">{
        return &amp;Analytics{
                transport: transport,
                startTime: time.Now(),
        }
}</span>

// ReportServerStarted reports that the MCP server has started.
func (a *Analytics) ReportServerStarted() <span class="cov8" title="1">{
        analytics.ReportEventWithProperties(analytics.MCPServerStarted, map[string]interface{}{
                "transport": a.transport,
                "os":        runtime.GOOS,
                "arch":      runtime.GOARCH,
        })
}</span>

// ReportServerStopped reports that the MCP server has stopped.
func (a *Analytics) ReportServerStopped() <span class="cov8" title="1">{
        analytics.ReportEventWithProperties(analytics.MCPServerStopped, map[string]interface{}{
                "transport":      a.transport,
                "uptime_seconds": time.Since(a.startTime).Seconds(),
        })
}</span>

// ReportToolCall reports a tool invocation with timing and success info.
// No file paths or code content is included.
func (a *Analytics) ReportToolCall(toolName string, durationMs int64, success bool) <span class="cov8" title="1">{
        analytics.ReportEventWithProperties(analytics.MCPToolCall, map[string]interface{}{
                "tool":        toolName,
                "duration_ms": durationMs,
                "success":     success,
                "transport":   a.transport,
        })
}</span>

// ReportIndexingStarted reports that indexing has begun.
func (a *Analytics) ReportIndexingStarted() <span class="cov8" title="1">{
        analytics.ReportEventWithProperties(analytics.MCPIndexingStarted, map[string]interface{}{
                "transport": a.transport,
        })
}</span>

// ReportIndexingComplete reports successful indexing completion.
// Only aggregate counts are reported, no file paths.
func (a *Analytics) ReportIndexingComplete(stats *IndexingStats) <span class="cov8" title="1">{
        props := map[string]interface{}{
                "transport":         a.transport,
                "duration_seconds":  stats.BuildDuration.Seconds(),
                "function_count":    stats.Functions,
                "call_edge_count":   stats.CallEdges,
                "module_count":      stats.Modules,
                "file_count":        stats.Files,
        }
        analytics.ReportEventWithProperties(analytics.MCPIndexingComplete, props)
}</span>

// ReportIndexingFailed reports indexing failure.
// Error messages are not included to avoid potential PII.
func (a *Analytics) ReportIndexingFailed(phase string) <span class="cov8" title="1">{
        analytics.ReportEventWithProperties(analytics.MCPIndexingFailed, map[string]interface{}{
                "transport": a.transport,
                "phase":     phase,
        })
}</span>

// ReportClientConnected reports a client connection with client info.
// Only client name/version (from MCP protocol) is reported.
func (a *Analytics) ReportClientConnected(clientName, clientVersion string) <span class="cov8" title="1">{
        analytics.ReportEventWithProperties(analytics.MCPClientConnected, map[string]interface{}{
                "transport":      a.transport,
                "client_name":    clientName,
                "client_version": clientVersion,
        })
}</span>

// ToolCallMetrics holds metrics for a tool call.
type ToolCallMetrics struct {
        StartTime time.Time
        ToolName  string
}

// StartToolCall begins tracking a tool call.
func (a *Analytics) StartToolCall(toolName string) *ToolCallMetrics <span class="cov8" title="1">{
        return &amp;ToolCallMetrics{
                StartTime: time.Now(),
                ToolName:  toolName,
        }
}</span>

// EndToolCall completes tracking and reports the metric.
func (a *Analytics) EndToolCall(m *ToolCallMetrics, success bool) <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">durationMs := time.Since(m.StartTime).Milliseconds()
        a.ReportToolCall(m.ToolName, durationMs, success)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package mcp

import (
        "encoding/json"
        "fmt"
)

// Standard JSON-RPC 2.0 error codes.
const (
        ErrCodeParseError     = -32700
        ErrCodeInvalidRequest = -32600
        ErrCodeMethodNotFound = -32601
        ErrCodeInvalidParams  = -32602
        ErrCodeInternalError  = -32603

        // Custom server error codes (-32000 to -32099).
        ErrCodeSymbolNotFound   = -32001
        ErrCodeIndexNotReady    = -32002
        ErrCodeQueryTimeout     = -32003
        ErrCodeResultsTruncated = -32004
)

// errorMessages maps error codes to default messages.
var errorMessages = map[int]string{
        ErrCodeParseError:       "Parse error",
        ErrCodeInvalidRequest:   "Invalid Request",
        ErrCodeMethodNotFound:   "Method not found",
        ErrCodeInvalidParams:    "Invalid params",
        ErrCodeInternalError:    "Internal error",
        ErrCodeSymbolNotFound:   "Symbol not found",
        ErrCodeIndexNotReady:    "Index not ready",
        ErrCodeQueryTimeout:     "Query timeout",
        ErrCodeResultsTruncated: "Results truncated",
}

// Error implements the error interface for RPCError.
func (e *RPCError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("[%d] %s", e.Code, e.Message)
}</span>

// NewRPCError creates a new RPC error with optional data.
func NewRPCError(code int, data interface{}) *RPCError <span class="cov8" title="1">{
        message := errorMessages[code]
        if message == "" </span><span class="cov8" title="1">{
                message = "Unknown error"
        }</span>
        <span class="cov8" title="1">return &amp;RPCError{
                Code:    code,
                Message: message,
                Data:    data,
        }</span>
}

// NewRPCErrorWithMessage creates an RPC error with custom message.
func NewRPCErrorWithMessage(code int, message string, data interface{}) *RPCError <span class="cov8" title="1">{
        return &amp;RPCError{
                Code:    code,
                Message: message,
                Data:    data,
        }
}</span>

// ParseError creates a parse error response.
func ParseError(detail string) *RPCError <span class="cov8" title="1">{
        return NewRPCErrorWithMessage(ErrCodeParseError, "Parse error: "+detail, nil)
}</span>

// InvalidRequestError creates an invalid request error.
func InvalidRequestError(detail string) *RPCError <span class="cov8" title="1">{
        return NewRPCErrorWithMessage(ErrCodeInvalidRequest, "Invalid request: "+detail, nil)
}</span>

// MethodNotFoundError creates a method not found error.
func MethodNotFoundError(method string) *RPCError <span class="cov8" title="1">{
        return NewRPCErrorWithMessage(ErrCodeMethodNotFound,
                fmt.Sprintf("Method not found: %s", method),
                map[string]string{"method": method})
}</span>

// InvalidParamsError creates an invalid params error.
func InvalidParamsError(detail string) *RPCError <span class="cov8" title="1">{
        return NewRPCErrorWithMessage(ErrCodeInvalidParams, "Invalid params: "+detail, nil)
}</span>

// InternalError creates an internal error.
func InternalError(detail string) *RPCError <span class="cov8" title="1">{
        return NewRPCErrorWithMessage(ErrCodeInternalError, "Internal error: "+detail, nil)
}</span>

// SymbolNotFoundError creates a symbol not found error with suggestions.
func SymbolNotFoundError(symbol string, suggestions []string) *RPCError <span class="cov8" title="1">{
        data := map[string]interface{}{
                "symbol": symbol,
        }
        if len(suggestions) &gt; 0 </span><span class="cov8" title="1">{
                data["suggestions"] = suggestions
        }</span>
        <span class="cov8" title="1">return NewRPCErrorWithMessage(ErrCodeSymbolNotFound,
                fmt.Sprintf("Symbol not found: %s", symbol), data)</span>
}

// IndexNotReadyError creates an index not ready error with optional progress info.
func IndexNotReadyError(phase string, progress float64) *RPCError <span class="cov8" title="1">{
        data := map[string]interface{}{
                "phase":    phase,
                "progress": progress,
        }
        return NewRPCErrorWithMessage(ErrCodeIndexNotReady,
                fmt.Sprintf("Index not ready: %s (%.0f%% complete)", phase, progress*100),
                data)
}</span>

// QueryTimeoutError creates a query timeout error.
func QueryTimeoutError(timeout string) *RPCError <span class="cov8" title="1">{
        return NewRPCErrorWithMessage(ErrCodeQueryTimeout,
                fmt.Sprintf("Query timed out after %s", timeout),
                map[string]string{"timeout": timeout})
}</span>

// MakeErrorResponse creates a JSON-RPC error response from an RPCError.
func MakeErrorResponse(id interface{}, err *RPCError) *JSONRPCResponse <span class="cov8" title="1">{
        return &amp;JSONRPCResponse{
                JSONRPC: "2.0",
                ID:      id,
                Error:   err,
        }
}</span>

// ToolError represents a structured tool error response.
type ToolError struct {
        Error   string      `json:"error"`
        Code    int         `json:"code,omitempty"`
        Details interface{} `json:"details,omitempty"`
}

// NewToolError creates a JSON-formatted tool error response.
func NewToolError(message string, code int, details interface{}) string <span class="cov8" title="1">{
        te := ToolError{
                Error:   message,
                Code:    code,
                Details: details,
        }
        bytes, _ := json.Marshal(te)
        return string(bytes)
}</span>

// ValidateRequiredParams checks for required parameters.
func ValidateRequiredParams(args map[string]interface{}, required []string) *RPCError <span class="cov8" title="1">{
        missing := []string{}
        for _, param := range required </span><span class="cov8" title="1">{
                if _, ok := args[param]; !ok </span><span class="cov8" title="1">{
                        missing = append(missing, param)
                }</span>
        }
        <span class="cov8" title="1">if len(missing) &gt; 0 </span><span class="cov8" title="1">{
                return InvalidParamsError(fmt.Sprintf("missing required parameters: %v", missing))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateStringParam validates a string parameter.
func ValidateStringParam(args map[string]interface{}, name string) (string, *RPCError) <span class="cov8" title="1">{
        val, ok := args[name]
        if !ok </span><span class="cov8" title="1">{
                return "", InvalidParamsError(fmt.Sprintf("missing required parameter: %s", name))
        }</span>
        <span class="cov8" title="1">str, ok := val.(string)
        if !ok </span><span class="cov8" title="1">{
                return "", InvalidParamsError(fmt.Sprintf("parameter %s must be a string", name))
        }</span>
        <span class="cov8" title="1">if str == "" </span><span class="cov8" title="1">{
                return "", InvalidParamsError(fmt.Sprintf("parameter %s cannot be empty", name))
        }</span>
        <span class="cov8" title="1">return str, nil</span>
}

// ValidateIntParam validates an integer parameter with optional default.
func ValidateIntParam(args map[string]interface{}, name string, defaultVal int) (int, *RPCError) <span class="cov8" title="1">{
        val, ok := args[name]
        if !ok </span><span class="cov8" title="1">{
                return defaultVal, nil
        }</span>

        // JSON numbers come as float64.
        <span class="cov8" title="1">switch v := val.(type) </span>{
        case float64:<span class="cov8" title="1">
                return int(v), nil</span>
        case int:<span class="cov8" title="1">
                return v, nil</span>
        default:<span class="cov8" title="1">
                return 0, InvalidParamsError(fmt.Sprintf("parameter %s must be a number", name))</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package mcp

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net"
        "net/http"
        "strings"
        "sync"
        "time"
)

// HTTPConfig holds configuration for the HTTP server.
type HTTPConfig struct {
        Address         string
        ReadTimeout     time.Duration
        WriteTimeout    time.Duration
        ShutdownTimeout time.Duration
        AllowedOrigins  []string
}

// DefaultHTTPConfig returns sensible defaults.
func DefaultHTTPConfig() *HTTPConfig <span class="cov8" title="1">{
        return &amp;HTTPConfig{
                Address:         ":8080",
                ReadTimeout:     30 * time.Second,
                WriteTimeout:    30 * time.Second,
                ShutdownTimeout: 5 * time.Second,
                AllowedOrigins:  []string{"*"},
        }
}</span>

// HTTPServer wraps the MCP server with HTTP transport.
type HTTPServer struct {
        server     *Server
        httpServer *http.Server
        config     *HTTPConfig
        mu         sync.RWMutex
        running    bool
}

// NewHTTPServer creates a new HTTP server wrapping the MCP server.
func NewHTTPServer(mcpServer *Server, config *HTTPConfig) *HTTPServer <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = DefaultHTTPConfig()
        }</span>

        <span class="cov8" title="1">return &amp;HTTPServer{
                server: mcpServer,
                config: config,
        }</span>
}

// ServeHTTP implements http.Handler for JSON-RPC requests.
func (h *HTTPServer) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Set CORS headers.
        h.setCORSHeaders(w, r)

        // Handle preflight requests.
        if r.Method == http.MethodOptions </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusNoContent)
                return
        }</span>

        // Only accept POST for JSON-RPC.
        <span class="cov8" title="1">if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusMethodNotAllowed, "Only POST method is allowed")
                return
        }</span>

        // Verify content type.
        <span class="cov8" title="1">contentType := r.Header.Get("Content-Type")
        if !strings.HasPrefix(contentType, "application/json") </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusUnsupportedMediaType, "Content-Type must be application/json")
                return
        }</span>

        // Read request body.
        <span class="cov8" title="1">body, err := io.ReadAll(io.LimitReader(r.Body, 1&lt;&lt;20)) // 1MB limit
        if err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, "Failed to read request body")
                return
        }</span>
        <span class="cov8" title="1">defer r.Body.Close()

        // Parse JSON-RPC request.
        var request JSONRPCRequest
        if err := json.Unmarshal(body, &amp;request); err != nil </span><span class="cov8" title="1">{
                response := MakeErrorResponse(nil, ParseError(err.Error()))
                h.writeJSON(w, http.StatusOK, response)
                return
        }</span>

        // Handle the request.
        <span class="cov8" title="1">response := h.server.handleRequest(&amp;request)

        // Write response.
        h.writeJSON(w, http.StatusOK, response)</span>
}

// Start starts the HTTP server.
func (h *HTTPServer) Start() error <span class="cov8" title="1">{
        h.mu.Lock()
        if h.running </span><span class="cov8" title="1">{
                h.mu.Unlock()
                return fmt.Errorf("server already running")
        }</span>

        <span class="cov8" title="1">mux := http.NewServeMux()
        mux.Handle("/", h)
        mux.HandleFunc("/health", h.healthHandler)

        h.httpServer = &amp;http.Server{
                Addr:         h.config.Address,
                Handler:      mux,
                ReadTimeout:  h.config.ReadTimeout,
                WriteTimeout: h.config.WriteTimeout,
        }

        h.running = true
        h.mu.Unlock()

        // Start listening.
        lc := net.ListenConfig{}
        listener, err := lc.Listen(context.Background(), "tcp", h.config.Address)
        if err != nil </span><span class="cov8" title="1">{
                h.mu.Lock()
                h.running = false
                h.mu.Unlock()
                return fmt.Errorf("failed to listen on %s: %w", h.config.Address, err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("MCP HTTP server listening on %s\n", h.config.Address)
        return h.httpServer.Serve(listener)</span>
}

// StartAsync starts the HTTP server in a goroutine and returns immediately.
func (h *HTTPServer) StartAsync() error <span class="cov8" title="1">{
        h.mu.Lock()
        if h.running </span><span class="cov8" title="1">{
                h.mu.Unlock()
                return fmt.Errorf("server already running")
        }</span>

        <span class="cov8" title="1">mux := http.NewServeMux()
        mux.Handle("/", h)
        mux.HandleFunc("/health", h.healthHandler)

        h.httpServer = &amp;http.Server{
                Addr:         h.config.Address,
                Handler:      mux,
                ReadTimeout:  h.config.ReadTimeout,
                WriteTimeout: h.config.WriteTimeout,
        }

        h.running = true
        h.mu.Unlock()

        // Start listening.
        lc := net.ListenConfig{}
        listener, err := lc.Listen(context.Background(), "tcp", h.config.Address)
        if err != nil </span><span class="cov8" title="1">{
                h.mu.Lock()
                h.running = false
                h.mu.Unlock()
                return fmt.Errorf("failed to listen on %s: %w", h.config.Address, err)
        }</span>

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                _ = h.httpServer.Serve(listener)
        }</span>()

        <span class="cov8" title="1">return nil</span>
}

// Shutdown gracefully shuts down the HTTP server.
func (h *HTTPServer) Shutdown(ctx context.Context) error <span class="cov8" title="1">{
        h.mu.Lock()
        if !h.running </span><span class="cov8" title="1">{
                h.mu.Unlock()
                return nil
        }</span>
        <span class="cov8" title="1">h.running = false
        h.mu.Unlock()

        if h.httpServer == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return h.httpServer.Shutdown(ctx)</span>
}

// IsRunning returns whether the server is running.
func (h *HTTPServer) IsRunning() bool <span class="cov8" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        return h.running
}</span>

// Address returns the configured address.
func (h *HTTPServer) Address() string <span class="cov8" title="1">{
        return h.config.Address
}</span>

// healthHandler returns server health status.
func (h *HTTPServer) healthHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        h.setCORSHeaders(w, r)

        if r.Method == http.MethodOptions </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusNoContent)
                return
        }</span>

        <span class="cov8" title="1">status := map[string]interface{}{
                "status":    "healthy",
                "timestamp": time.Now().UTC().Format(time.RFC3339),
        }

        h.writeJSON(w, http.StatusOK, status)</span>
}

// setCORSHeaders sets CORS headers based on configuration.
func (h *HTTPServer) setCORSHeaders(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        origin := r.Header.Get("Origin")
        if origin == "" </span><span class="cov8" title="1">{
                origin = "*"
        }</span>

        // Check if origin is allowed.
        <span class="cov8" title="1">allowed := false
        for _, o := range h.config.AllowedOrigins </span><span class="cov8" title="1">{
                if o == "*" || o == origin </span><span class="cov8" title="1">{
                        allowed = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                w.Header().Set("Access-Control-Allow-Origin", origin)
        }</span>

        <span class="cov8" title="1">w.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        w.Header().Set("Access-Control-Max-Age", "86400")</span>
}

// writeJSON writes a JSON response.
func (h *HTTPServer) writeJSON(w http.ResponseWriter, status int, data interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        _ = json.NewEncoder(w).Encode(data)
}</span>

// writeError writes an error response.
func (h *HTTPServer) writeError(w http.ResponseWriter, status int, message string) <span class="cov8" title="1">{
        h.writeJSON(w, status, map[string]string{"error": message})
}</span>

// SSEServer provides Server-Sent Events transport for streaming.
type SSEServer struct {
        httpServer *HTTPServer
}

// NewSSEServer creates a new SSE server.
func NewSSEServer(httpServer *HTTPServer) *SSEServer <span class="cov8" title="1">{
        return &amp;SSEServer{httpServer: httpServer}
}</span>

// ServeSSE handles SSE connections for streaming responses.
func (s *SSEServer) ServeSSE(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Set SSE headers.
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")
        s.httpServer.setCORSHeaders(w, r)

        flusher, ok := w.(http.Flusher)
        if !ok </span><span class="cov8" title="1">{
                http.Error(w, "SSE not supported", http.StatusInternalServerError)
                return
        }</span>

        // Send initial connection event.
        <span class="cov8" title="1">fmt.Fprintf(w, "event: connected\ndata: {\"status\": \"connected\"}\n\n")
        flusher.Flush()

        // Keep connection open until client disconnects.
        &lt;-r.Context().Done()</span>
}

// StreamingHTTPHandler provides a handler for streaming JSON-RPC over HTTP.
type StreamingHTTPHandler struct {
        server *Server
}

// NewStreamingHTTPHandler creates a new streaming handler.
func NewStreamingHTTPHandler(server *Server) *StreamingHTTPHandler <span class="cov8" title="1">{
        return &amp;StreamingHTTPHandler{server: server}
}</span>

// HandleStream processes a stream of JSON-RPC requests.
func (s *StreamingHTTPHandler) HandleStream(r io.Reader, w io.Writer) error <span class="cov8" title="1">{
        scanner := bufio.NewScanner(r)
        encoder := json.NewEncoder(w)

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">var request JSONRPCRequest
                if err := json.Unmarshal([]byte(line), &amp;request); err != nil </span><span class="cov8" title="1">{
                        response := MakeErrorResponse(nil, ParseError(err.Error()))
                        if err := encoder.Encode(response); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">response := s.server.handleRequest(&amp;request)
                if err := encoder.Encode(response); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return scanner.Err()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package mcp provides instance resolution tools for the MCP server.
package mcp

import (
        "context"
        "encoding/json"
        "fmt"

        sitter "github.com/smacker/go-tree-sitter"
        python "github.com/smacker/go-tree-sitter/python"
        "github.com/shivasurya/code-pathfinder/sast-engine/graph/callgraph/core"
        "github.com/shivasurya/code-pathfinder/sast-engine/graph/callgraph/resolution"
        "github.com/shivasurya/code-pathfinder/sast-engine/graph/callgraph/resolution/strategies"
)

// =============================================================================
// REQUEST/RESPONSE TYPES
// =============================================================================

// ResolveInstanceCallRequest represents the input for resolve_instance_call.
type ResolveInstanceCallRequest struct {
        Expression string                 `json:"expression"`
        FilePath   string                 `json:"file_path"` //nolint:tagliatelle // MCP protocol uses snake_case
        Line       int                    `json:"line"`
        Column     int                    `json:"column"`
        Context    *InstanceCallContext   `json:"context,omitempty"`
}

// InstanceCallContext provides additional context for resolution.
type InstanceCallContext struct {
        SelfType  string            `json:"self_type,omitempty"` //nolint:tagliatelle // MCP protocol uses snake_case
        Variables map[string]string `json:"variables,omitempty"`
}

// ResolveInstanceCallResponse represents the output for resolve_instance_call.
type ResolveInstanceCallResponse struct {
        Success      bool                `json:"success"`
        ResolvedType string              `json:"resolved_type,omitempty"` //nolint:tagliatelle // MCP protocol uses snake_case
        Method       string              `json:"method,omitempty"`
        CanonicalFQN string              `json:"canonical_fqn,omitempty"` //nolint:tagliatelle // MCP protocol uses snake_case
        Definition   *DefinitionLocation `json:"definition,omitempty"`
        Confidence   float64             `json:"confidence"`
        Error        string              `json:"error,omitempty"`
}

// DefinitionLocation represents where a method is defined.
type DefinitionLocation struct {
        FilePath  string `json:"file_path"` //nolint:tagliatelle // MCP protocol uses snake_case
        Line      int    `json:"line"`
        Column    int    `json:"column"`
        Signature string `json:"signature,omitempty"`
        Docstring string `json:"docstring,omitempty"`
}

// GetInstanceTypeRequest represents the input for get_instance_type.
type GetInstanceTypeRequest struct {
        Variable string `json:"variable"`
        FilePath string `json:"file_path"` //nolint:tagliatelle // MCP protocol uses snake_case
        Line     int    `json:"line"`
}

// GetInstanceTypeResponse represents the output for get_instance_type.
type GetInstanceTypeResponse struct {
        Success    bool    `json:"success"`
        TypeFQN    string  `json:"type_fqn,omitempty"` //nolint:tagliatelle // MCP protocol uses snake_case
        Confidence float64 `json:"confidence"`
        Source     string  `json:"source,omitempty"`
        Error      string  `json:"error,omitempty"`
}

// =============================================================================
// TOOL HANDLER
// =============================================================================

// InstanceToolHandler handles instance resolution MCP tools.
type InstanceToolHandler struct {
        inferencer   *resolution.BidirectionalInferencer
        attrRegistry strategies.AttributeRegistryInterface
        callGraph    *core.CallGraph
}

// NewInstanceToolHandler creates a new InstanceToolHandler.
func NewInstanceToolHandler(
        inferencer *resolution.BidirectionalInferencer,
        attrRegistry strategies.AttributeRegistryInterface,
        callGraph *core.CallGraph,
) *InstanceToolHandler <span class="cov8" title="1">{
        return &amp;InstanceToolHandler{
                inferencer:   inferencer,
                attrRegistry: attrRegistry,
                callGraph:    callGraph,
        }
}</span>

// HandleResolveInstanceCall handles the resolve_instance_call tool.
func (h *InstanceToolHandler) HandleResolveInstanceCall(args json.RawMessage) (*ResolveInstanceCallResponse, error) <span class="cov8" title="1">{
        var req ResolveInstanceCallRequest
        if err := json.Unmarshal(args, &amp;req); err != nil </span><span class="cov8" title="1">{
                return &amp;ResolveInstanceCallResponse{
                        Success: false,
                        Error:   fmt.Sprintf("invalid request: %v", err),
                }, nil
        }</span>

        // Parse the expression
        <span class="cov8" title="1">parser := sitter.NewParser()
        parser.SetLanguage(python.GetLanguage())

        tree, err := parser.ParseCtx(context.Background(), nil, []byte(req.Expression))
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ResolveInstanceCallResponse{
                        Success: false,
                        Error:   fmt.Sprintf("failed to parse expression: %v", err),
                }, nil
        }</span>

        <span class="cov8" title="1">rootNode := tree.RootNode()
        if rootNode.ChildCount() == 0 </span><span class="cov8" title="1">{
                return &amp;ResolveInstanceCallResponse{
                        Success: false,
                        Error:   "empty expression",
                }, nil
        }</span>

        // Get the expression node (skip expression_statement wrapper)
        <span class="cov8" title="1">exprNode := rootNode.Child(0)
        if exprNode.Type() == "expression_statement" &amp;&amp; exprNode.ChildCount() &gt; 0 </span><span class="cov8" title="1">{
                exprNode = exprNode.Child(0)
        }</span>

        // Set up resolution context
        <span class="cov8" title="1">store := resolution.NewTypeStore()

        // Add context variables
        if req.Context != nil </span><span class="cov8" title="1">{
                for varName, typeFQN := range req.Context.Variables </span><span class="cov8" title="1">{
                        store.Set(varName, core.NewConcreteType(typeFQN, 0.95),
                                core.ConfidenceAssignment, req.FilePath, req.Line, req.Column)
                }</span>
        }

        // Set up self type
        <span class="cov8" title="1">var selfType core.Type
        var classFQN string
        if req.Context != nil &amp;&amp; req.Context.SelfType != "" </span><span class="cov8" title="1">{
                selfType = core.NewConcreteType(req.Context.SelfType, 0.95)
                classFQN = req.Context.SelfType
        }</span>

        // Resolve the expression
        <span class="cov8" title="1">resolvedType, confidence := h.inferencer.InferType(
                exprNode,
                store,
                []byte(req.Expression),
                req.FilePath,
                selfType,
                classFQN,
                "",
        )

        if core.IsAnyType(resolvedType) </span><span class="cov8" title="1">{
                return &amp;ResolveInstanceCallResponse{
                        Success:    false,
                        Confidence: confidence,
                        Error:      "could not resolve expression type",
                }, nil
        }</span>

        // Extract method name from expression
        <span class="cov8" title="1">methodName := h.extractMethodName(exprNode, []byte(req.Expression))

        // Build canonical FQN
        canonicalFQN := resolvedType.FQN()
        if methodName != "" </span><span class="cov8" title="1">{
                canonicalFQN = canonicalFQN + "." + methodName
        }</span>

        // Look up definition location
        <span class="cov8" title="1">definition := h.lookupDefinition(resolvedType.FQN(), methodName)

        return &amp;ResolveInstanceCallResponse{
                Success:      true,
                ResolvedType: resolvedType.FQN(),
                Method:       methodName,
                CanonicalFQN: canonicalFQN,
                Definition:   definition,
                Confidence:   confidence,
        }, nil</span>
}

// extractMethodName extracts the method name from a call expression.
func (h *InstanceToolHandler) extractMethodName(node *sitter.Node, source []byte) string <span class="cov8" title="1">{
        if node == nil || node.Type() != "call" </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">funcNode := node.ChildByFieldName("function")
        if funcNode == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">if funcNode.Type() == "attribute" </span><span class="cov8" title="1">{
                attrNode := funcNode.ChildByFieldName("attribute")
                if attrNode != nil </span><span class="cov8" title="1">{
                        return string(source[attrNode.StartByte():attrNode.EndByte()])
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// lookupDefinition finds where a method is defined.
func (h *InstanceToolHandler) lookupDefinition(classFQN, methodName string) *DefinitionLocation <span class="cov8" title="1">{
        if h.attrRegistry == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">classAttrs := h.attrRegistry.GetClassAttributes(classFQN)
        if classAttrs == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Check if method exists
        <span class="cov8" title="1">methodFQN := classFQN + "." + methodName
        for _, m := range classAttrs.Methods </span><span class="cov8" title="1">{
                if m == methodFQN </span><span class="cov8" title="1">{
                        // Return basic location from class (detailed location would require method registry)
                        return &amp;DefinitionLocation{
                                FilePath: classAttrs.FilePath,
                                Line:     0, // Would need method-level tracking
                                Column:   0,
                        }
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// HandleGetInstanceType handles the get_instance_type tool.
func (h *InstanceToolHandler) HandleGetInstanceType(args json.RawMessage) (*GetInstanceTypeResponse, error) <span class="cov8" title="1">{
        var req GetInstanceTypeRequest
        if err := json.Unmarshal(args, &amp;req); err != nil </span><span class="cov8" title="1">{
                return &amp;GetInstanceTypeResponse{
                        Success: false,
                        Error:   fmt.Sprintf("invalid request: %v", err),
                }, nil
        }</span>

        // Create a simple expression from the variable name
        <span class="cov8" title="1">parser := sitter.NewParser()
        parser.SetLanguage(python.GetLanguage())

        tree, err := parser.ParseCtx(context.Background(), nil, []byte(req.Variable))
        if err != nil </span><span class="cov0" title="0">{
                return &amp;GetInstanceTypeResponse{ //nolint:nilerr // MCP pattern: errors embedded in response
                        Success: false,
                        Error:   "failed to parse variable",
                }, nil
        }</span>

        <span class="cov8" title="1">store := resolution.NewTypeStore()

        resolvedType, confidence := h.inferencer.InferType(
                tree.RootNode().Child(0).Child(0),
                store,
                []byte(req.Variable),
                req.FilePath,
                nil,
                "",
                "",
        )

        if core.IsAnyType(resolvedType) </span><span class="cov8" title="1">{
                return &amp;GetInstanceTypeResponse{
                        Success: false,
                        Error:   "variable type unknown",
                }, nil
        }</span>

        <span class="cov8" title="1">return &amp;GetInstanceTypeResponse{
                Success:    true,
                TypeFQN:    resolvedType.FQN(),
                Confidence: confidence,
                Source:     "type_inference",
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package mcp

import (
        "encoding/base64"
        "encoding/json"
        "fmt"
)

// Default and max limits.
const (
        DefaultLimit = 50
        MaxLimit     = 500
)

// PaginationParams holds pagination parameters from request.
type PaginationParams struct {
        Limit  int    `json:"limit"`
        Cursor string `json:"cursor"`
}

// PaginationInfo holds pagination metadata for response.
type PaginationInfo struct {
        Total      int    `json:"total"`
        Returned   int    `json:"returned"`
        HasMore    bool   `json:"hasMore"`
        NextCursor string `json:"nextCursor,omitempty"`
}

// Cursor represents an opaque pagination cursor.
type Cursor struct {
        Offset int    `json:"o"`
        Query  string `json:"q,omitempty"`
}

// EncodeCursor creates an opaque cursor string.
func EncodeCursor(offset int, query string) string <span class="cov8" title="1">{
        c := Cursor{Offset: offset, Query: query}
        bytes, _ := json.Marshal(c)
        return base64.URLEncoding.EncodeToString(bytes)
}</span>

// DecodeCursor parses a cursor string.
func DecodeCursor(cursor string) (*Cursor, error) <span class="cov8" title="1">{
        if cursor == "" </span><span class="cov8" title="1">{
                return &amp;Cursor{Offset: 0}, nil
        }</span>

        <span class="cov8" title="1">bytes, err := base64.URLEncoding.DecodeString(cursor)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid cursor: %w", err)
        }</span>

        <span class="cov8" title="1">var c Cursor
        if err := json.Unmarshal(bytes, &amp;c); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid cursor format: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;c, nil</span>
}

// ExtractPaginationParams extracts and validates pagination params.
func ExtractPaginationParams(args map[string]interface{}) (*PaginationParams, *RPCError) <span class="cov8" title="1">{
        params := &amp;PaginationParams{
                Limit: DefaultLimit,
        }

        // Extract limit.
        if limitVal, ok := args["limit"]; ok </span><span class="cov8" title="1">{
                switch v := limitVal.(type) </span>{
                case float64:<span class="cov8" title="1">
                        params.Limit = int(v)</span>
                case int:<span class="cov8" title="1">
                        params.Limit = v</span>
                default:<span class="cov8" title="1">
                        return nil, InvalidParamsError("limit must be a number")</span>
                }
        }

        // Validate limit.
        <span class="cov8" title="1">if params.Limit &lt;= 0 </span><span class="cov8" title="1">{
                params.Limit = DefaultLimit
        }</span>
        <span class="cov8" title="1">if params.Limit &gt; MaxLimit </span><span class="cov8" title="1">{
                params.Limit = MaxLimit
        }</span>

        // Extract cursor.
        <span class="cov8" title="1">if cursorVal, ok := args["cursor"].(string); ok </span><span class="cov8" title="1">{
                params.Cursor = cursorVal
        }</span>

        <span class="cov8" title="1">return params, nil</span>
}

// PaginateSlice applies pagination to a slice of any type.
func PaginateSlice[T any](items []T, params *PaginationParams) ([]T, *PaginationInfo) <span class="cov8" title="1">{
        total := len(items)

        // Decode cursor to get offset.
        cursor, err := DecodeCursor(params.Cursor)
        if err != nil </span><span class="cov8" title="1">{
                cursor = &amp;Cursor{Offset: 0}
        }</span>

        <span class="cov8" title="1">offset := cursor.Offset
        limit := params.Limit

        // Bounds check.
        if offset &gt;= total </span><span class="cov8" title="1">{
                return []T{}, &amp;PaginationInfo{
                        Total:    total,
                        Returned: 0,
                        HasMore:  false,
                }
        }</span>

        <span class="cov8" title="1">end := offset + limit
        if end &gt; total </span><span class="cov8" title="1">{
                end = total
        }</span>

        <span class="cov8" title="1">result := items[offset:end]
        hasMore := end &lt; total

        info := &amp;PaginationInfo{
                Total:    total,
                Returned: len(result),
                HasMore:  hasMore,
        }

        if hasMore </span><span class="cov8" title="1">{
                info.NextCursor = EncodeCursor(end, cursor.Query)
        }</span>

        <span class="cov8" title="1">return result, info</span>
}

// PaginatedResult wraps results with pagination info.
type PaginatedResult struct {
        Items      interface{}    `json:"items"`
        Pagination PaginationInfo `json:"pagination"`
}

// NewPaginatedResult creates a paginated result.
func NewPaginatedResult(items interface{}, info *PaginationInfo) *PaginatedResult <span class="cov8" title="1">{
        return &amp;PaginatedResult{
                Items:      items,
                Pagination: *info,
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package mcp provides query standardization for MCP.
package mcp

import (
        "regexp"
        "strings"

        "github.com/shivasurya/code-pathfinder/sast-engine/graph/callgraph/core"
        "github.com/shivasurya/code-pathfinder/sast-engine/graph/callgraph/resolution"
        "github.com/shivasurya/code-pathfinder/sast-engine/graph/callgraph/resolution/strategies"
)

// QueryResolver standardizes various query formats to canonical FQN.
type QueryResolver struct {
        inferencer   *resolution.BidirectionalInferencer
        attrRegistry strategies.AttributeRegistryInterface
}

// NewQueryResolver creates a new QueryResolver.
func NewQueryResolver(
        inferencer *resolution.BidirectionalInferencer,
        attrRegistry strategies.AttributeRegistryInterface,
) *QueryResolver <span class="cov8" title="1">{
        return &amp;QueryResolver{
                inferencer:   inferencer,
                attrRegistry: attrRegistry,
        }
}</span>

// QueryPattern represents a recognized query pattern.
type QueryPattern int

const (
        // PatternUnknown represents an unrecognized pattern.
        PatternUnknown QueryPattern = iota
        // PatternDirectFQN represents myapp.models.User.get_name.
        PatternDirectFQN
        // PatternInstanceCall represents user.get_name().
        PatternInstanceCall
        // PatternSelfCall represents self.process().
        PatternSelfCall
        // PatternChainedCall represents app.service.run().
        PatternChainedCall
        // PatternInlineInstantiation represents UserService().get_user().
        PatternInlineInstantiation
        // PatternStaticMethod represents ClassName.static_method().
        PatternStaticMethod
        // PatternClassMethod represents ClassName.class_method().
        PatternClassMethod
)

// StandardizedQuery represents a normalized query.
type StandardizedQuery struct {
        OriginalQuery string
        Pattern       QueryPattern
        CanonicalFQN  string
        ClassName     string
        MethodName    string
        Confidence    float64
        RequiresIndex bool   // True if we need to look up in index
        IndexQuery    string // The query to use for index lookup
}

// StandardizeQuery converts a user query to canonical form.
func (r *QueryResolver) StandardizeQuery(
        query string,
        knownVariables map[string]string,
        selfType string,
) *StandardizedQuery <span class="cov8" title="1">{
        query = strings.TrimSpace(query)

        // Try to detect the pattern
        pattern, parts := r.detectPattern(query)

        result := &amp;StandardizedQuery{
                OriginalQuery: query,
                Pattern:       pattern,
                RequiresIndex: true,
        }

        switch pattern </span>{
        case PatternDirectFQN:<span class="cov8" title="1">
                // Already canonical: myapp.models.User.get_name
                result.CanonicalFQN = query
                result.extractClassMethod(query)
                result.IndexQuery = query
                result.Confidence = 1.0</span>

        case PatternInstanceCall:<span class="cov8" title="1">
                // user.get_name() - need to resolve 'user' type
                varName := parts["variable"]
                methodName := parts["method"]

                if typeFQN, ok := knownVariables[varName]; ok </span><span class="cov8" title="1">{
                        result.ClassName = typeFQN
                        result.MethodName = methodName
                        result.CanonicalFQN = typeFQN + "." + methodName
                        result.IndexQuery = result.CanonicalFQN
                        result.Confidence = 0.85
                }</span> else<span class="cov8" title="1"> {
                        result.Confidence = 0.0
                        result.RequiresIndex = false // Can't resolve without type info
                }</span>

        case PatternSelfCall:<span class="cov8" title="1">
                // self.process() - use selfType
                methodName := parts["method"]

                if selfType != "" </span><span class="cov8" title="1">{
                        result.ClassName = selfType
                        result.MethodName = methodName
                        result.CanonicalFQN = selfType + "." + methodName
                        result.IndexQuery = result.CanonicalFQN
                        result.Confidence = 0.95
                }</span> else<span class="cov8" title="1"> {
                        result.Confidence = 0.0
                        result.RequiresIndex = false
                }</span>

        case PatternChainedCall:<span class="cov8" title="1">
                // app.service.run() - need to resolve chain
                result.RequiresIndex = true
                result.Confidence = 0.0</span> // Will be filled by chain resolution

        case PatternInlineInstantiation:<span class="cov8" title="1">
                // UserService().get_user() - class is in the expression
                className := parts["class"]
                methodName := parts["method"]

                result.ClassName = className
                result.MethodName = methodName
                result.CanonicalFQN = className + "." + methodName
                result.IndexQuery = result.CanonicalFQN
                result.Confidence = 0.90</span>

        case PatternStaticMethod, PatternClassMethod:<span class="cov8" title="1">
                // ClassName.method() - direct class reference
                className := parts["class"]
                methodName := parts["method"]

                result.ClassName = className
                result.MethodName = methodName
                result.CanonicalFQN = className + "." + methodName
                result.IndexQuery = result.CanonicalFQN
                result.Confidence = 0.95</span>

        default:<span class="cov8" title="1">
                result.Confidence = 0.0
                result.RequiresIndex = false</span>
        }

        <span class="cov8" title="1">return result</span>
}

// detectPattern identifies the query pattern.
func (r *QueryResolver) detectPattern(query string) (QueryPattern, map[string]string) <span class="cov8" title="1">{
        parts := make(map[string]string)

        // Pattern: self.method() or self.method
        if selfPattern := regexp.MustCompile(`^self\.(\w+)(\(\))?$`); selfPattern.MatchString(query) </span><span class="cov8" title="1">{
                matches := selfPattern.FindStringSubmatch(query)
                parts["method"] = matches[1]
                return PatternSelfCall, parts
        }</span>

        // Pattern: ClassName().method() or ClassName().method (inline instantiation)
        <span class="cov8" title="1">if inlinePattern := regexp.MustCompile(`^([A-Z]\w*)\(\)\.(\w+)(\(\))?$`); inlinePattern.MatchString(query) </span><span class="cov8" title="1">{
                matches := inlinePattern.FindStringSubmatch(query)
                parts["class"] = matches[1]
                parts["method"] = matches[2]
                return PatternInlineInstantiation, parts
        }</span>

        // Pattern: ClassName.method() or ClassName.method (static/class method)
        <span class="cov8" title="1">if staticPattern := regexp.MustCompile(`^([A-Z]\w*)\.(\w+)(\(\))?$`); staticPattern.MatchString(query) </span><span class="cov8" title="1">{
                matches := staticPattern.FindStringSubmatch(query)
                parts["class"] = matches[1]
                parts["method"] = matches[2]
                return PatternStaticMethod, parts
        }</span>

        // Pattern: module.class.method (direct FQN) - Check before instance/chain patterns
        // Must have 3+ segments and no parentheses to be FQN
        <span class="cov8" title="1">if fqnPattern := regexp.MustCompile(`^[\w.]+\.\w+$`); fqnPattern.MatchString(query) </span><span class="cov8" title="1">{
                // Check if it looks like FQN (has at least module.class.method)
                segments := strings.Split(query, ".")
                if len(segments) &gt;= 3 &amp;&amp; !strings.Contains(query, "(") </span><span class="cov8" title="1">{
                        return PatternDirectFQN, parts
                }</span>
        }

        // Pattern: variable.method() or variable.method (instance call)
        <span class="cov8" title="1">if instancePattern := regexp.MustCompile(`^([a-z_]\w*)\.(\w+)(\(\))?$`); instancePattern.MatchString(query) </span><span class="cov8" title="1">{
                matches := instancePattern.FindStringSubmatch(query)
                parts["variable"] = matches[1]
                parts["method"] = matches[2]
                return PatternInstanceCall, parts
        }</span>

        // Pattern: a.b.c.method() or a.b.c.method (chained call)
        <span class="cov8" title="1">if chainPattern := regexp.MustCompile(`^[a-z_]\w*(\.\w+){2,}(\(\))?$`); chainPattern.MatchString(query) </span><span class="cov8" title="1">{
                return PatternChainedCall, parts
        }</span>

        <span class="cov8" title="1">return PatternUnknown, parts</span>
}

// extractClassMethod extracts class and method from a canonical FQN.
func (sq *StandardizedQuery) extractClassMethod(fqn string) <span class="cov8" title="1">{
        parts := strings.Split(fqn, ".")
        if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                sq.MethodName = parts[len(parts)-1]
                sq.ClassName = strings.Join(parts[:len(parts)-1], ".")
        }</span>
}

// ResolveChainedQuery resolves chained queries like app.service.run().
func (r *QueryResolver) ResolveChainedQuery(
        query string,
        filePath string,
        knownVariables map[string]string,
        selfType string,
) *StandardizedQuery <span class="cov8" title="1">{
        result := &amp;StandardizedQuery{
                OriginalQuery: query,
                Pattern:       PatternChainedCall,
                RequiresIndex: true,
        }

        // Build TypeStore from known variables
        store := resolution.NewTypeStore()
        for varName, typeFQN := range knownVariables </span><span class="cov8" title="1">{
                store.Set(varName, core.NewConcreteType(typeFQN, 0.95),
                        core.ConfidenceAssignment, filePath, 0, 0)
        }</span>

        <span class="cov8" title="1">var selfTyp core.Type
        if selfType != "" </span><span class="cov8" title="1">{
                selfTyp = core.NewConcreteType(selfType, 0.95)
        }</span>

        // Use ChainResolver
        <span class="cov8" title="1">resolver := resolution.NewChainResolver(r.attrRegistry, nil, nil).
                WithContext(filePath, []byte(query)).
                WithSelf(selfTyp, selfType)

        for varName, typeFQN := range knownVariables </span><span class="cov8" title="1">{
                resolver.WithVariable(varName, core.NewConcreteType(typeFQN, 0.95))
        }</span>

        // Parse and resolve
        // (simplified - actual implementation would parse the query)

        <span class="cov8" title="1">result.Confidence = 0.7 // Chain resolution has lower confidence
        return result</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package mcp

import (
        "bufio"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "time"

        "github.com/shivasurya/code-pathfinder/sast-engine/graph"
        "github.com/shivasurya/code-pathfinder/sast-engine/graph/callgraph/core"
)

// Server handles MCP protocol communication.
type Server struct {
        projectPath    string
        pythonVersion  string
        callGraph      *core.CallGraph
        moduleRegistry *core.ModuleRegistry
        codeGraph      *graph.CodeGraph
        indexedAt      time.Time
        buildTime      time.Duration
        statusTracker  *StatusTracker
        degradation    *GracefulDegradation
        analytics      *Analytics
}

// NewServer creates a new MCP server with the given index data.
func NewServer(
        projectPath string,
        pythonVersion string,
        callGraph *core.CallGraph,
        moduleRegistry *core.ModuleRegistry,
        codeGraph *graph.CodeGraph,
        buildTime time.Duration,
) *Server <span class="cov8" title="1">{
        tracker := NewStatusTracker()

        // Mark as ready since we're being created with complete data.
        tracker.StartIndexing()
        stats := &amp;IndexingStats{
                Functions:     len(callGraph.Functions),
                CallEdges:     len(callGraph.Edges),
                Modules:       len(moduleRegistry.Modules),
                Files:         len(moduleRegistry.FileToModule),
                BuildDuration: buildTime,
        }
        tracker.CompleteIndexing(stats)

        // Initialize analytics with stdio transport (default).
        mcpAnalytics := NewAnalytics("stdio")
        mcpAnalytics.ReportIndexingComplete(stats)

        return &amp;Server{
                projectPath:    projectPath,
                pythonVersion:  pythonVersion,
                callGraph:      callGraph,
                moduleRegistry: moduleRegistry,
                codeGraph:      codeGraph,
                indexedAt:      time.Now(),
                buildTime:      buildTime,
                statusTracker:  tracker,
                degradation:    NewGracefulDegradation(tracker),
                analytics:      mcpAnalytics,
        }
}</span>

// SetTransport updates the analytics transport type (e.g., "http").
func (s *Server) SetTransport(transport string) <span class="cov8" title="1">{
        s.analytics = NewAnalytics(transport)
}</span>

// ServeStdio starts the MCP server on stdin/stdout.
func (s *Server) ServeStdio() error <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)

        // Report server started.
        s.analytics.ReportServerStarted()
        defer s.analytics.ReportServerStopped()

        for </span><span class="cov0" title="0">{
                // Read line from stdin.
                line, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                fmt.Fprintln(os.Stderr, "Client disconnected")
                                return nil // Clean shutdown
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("read error: %w", err)</span>
                }

                // Skip empty lines.
                <span class="cov0" title="0">if len(line) &lt;= 1 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse JSON-RPC request.
                <span class="cov0" title="0">var request JSONRPCRequest
                if err := json.Unmarshal([]byte(line), &amp;request); err != nil </span><span class="cov0" title="0">{
                        s.sendResponse(MakeErrorResponse(nil, ParseError(err.Error())))
                        continue</span>
                }

                // Handle request and send response.
                <span class="cov0" title="0">response := s.handleRequest(&amp;request)
                if response != nil </span><span class="cov0" title="0">{
                        s.sendResponse(response)
                }</span>
        }
}

// sendResponse writes a JSON-RPC response to stdout.
func (s *Server) sendResponse(resp *JSONRPCResponse) <span class="cov8" title="1">{
        bytes, err := json.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to marshal response: %v\n", err)
                return
        }</span>
        <span class="cov8" title="1">fmt.Println(string(bytes))</span>
}

// handleRequest dispatches to the appropriate handler.
func (s *Server) handleRequest(req *JSONRPCRequest) *JSONRPCResponse <span class="cov8" title="1">{
        startTime := time.Now()

        // Validate JSON-RPC version.
        if req.JSONRPC != "2.0" </span><span class="cov8" title="1">{
                return MakeErrorResponse(req.ID, InvalidRequestError("jsonrpc must be '2.0'"))
        }</span>

        // Validate method exists.
        <span class="cov8" title="1">if req.Method == "" </span><span class="cov8" title="1">{
                return MakeErrorResponse(req.ID, InvalidRequestError("method is required"))
        }</span>

        <span class="cov8" title="1">var response *JSONRPCResponse

        switch req.Method </span>{
        case "initialize":<span class="cov8" title="1">
                response = s.handleInitialize(req)</span>
        case "initialized":<span class="cov8" title="1">
                // Acknowledgment notification - no response needed.
                fmt.Fprintln(os.Stderr, "Client initialized")
                return nil</span>
        case "notifications/initialized":<span class="cov8" title="1">
                // Alternative notification format.
                return nil</span>
        case "tools/list":<span class="cov8" title="1">
                response = s.handleToolsList(req)</span>
        case "tools/call":<span class="cov8" title="1">
                response = s.handleToolsCall(req)</span>
        case "status":<span class="cov8" title="1">
                response = s.handleStatus(req)</span>
        case "ping":<span class="cov8" title="1">
                response = SuccessResponse(req.ID, map[string]string{"status": "ok"})</span>
        default:<span class="cov8" title="1">
                response = MakeErrorResponse(req.ID, MethodNotFoundError(req.Method))</span>
        }

        // Log request timing.
        <span class="cov8" title="1">elapsed := time.Since(startTime)
        fmt.Fprintf(os.Stderr, "[%s] %s (%v)\n", req.Method, "completed", elapsed)

        return response</span>
}

// handleInitialize responds to the initialize request.
func (s *Server) handleInitialize(req *JSONRPCRequest) *JSONRPCResponse <span class="cov8" title="1">{
        // Parse client info if needed.
        var params InitializeParams
        if req.Params != nil </span><span class="cov8" title="1">{
                _ = json.Unmarshal(req.Params, &amp;params)
                fmt.Fprintf(os.Stderr, "Client: %s %s\n", params.ClientInfo.Name, params.ClientInfo.Version)

                // Report client connection (only name/version, no PII).
                s.analytics.ReportClientConnected(params.ClientInfo.Name, params.ClientInfo.Version)
        }</span>

        <span class="cov8" title="1">return SuccessResponse(req.ID, InitializeResult{
                ProtocolVersion: "2024-11-05",
                ServerInfo: ServerInfo{
                        Name:    "pathfinder",
                        Version: "0.1.0-poc",
                },
                Capabilities: Capabilities{
                        Tools: &amp;ToolsCapability{
                                ListChanged: false,
                        },
                },
        })</span>
}

// handleToolsList returns the list of available tools.
func (s *Server) handleToolsList(req *JSONRPCRequest) *JSONRPCResponse <span class="cov8" title="1">{
        tools := s.getToolDefinitions()
        return SuccessResponse(req.ID, ToolsListResult{
                Tools: tools,
        })
}</span>

// handleToolsCall executes a tool.
func (s *Server) handleToolsCall(req *JSONRPCRequest) *JSONRPCResponse <span class="cov8" title="1">{
        var params ToolCallParams
        if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov8" title="1">{
                return MakeErrorResponse(req.ID, InvalidParamsError(err.Error()))
        }</span>

        <span class="cov8" title="1">if params.Name == "" </span><span class="cov8" title="1">{
                return MakeErrorResponse(req.ID, InvalidParamsError("tool name is required"))
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(os.Stderr, "Tool call: %s\n", params.Name)

        // Track tool call metrics.
        metrics := s.analytics.StartToolCall(params.Name)
        result, isError := s.executeTool(params.Name, params.Arguments)
        s.analytics.EndToolCall(metrics, !isError)

        return SuccessResponse(req.ID, ToolResult{
                Content: []ContentBlock{
                        {
                                Type: "text",
                                Text: result,
                        },
                },
                IsError: isError,
        })</span>
}

// handleStatus returns the current indexing status.
func (s *Server) handleStatus(req *JSONRPCRequest) *JSONRPCResponse <span class="cov8" title="1">{
        return SuccessResponse(req.ID, s.degradation.GetStatusJSON())
}</span>

// GetStatusTracker returns the status tracker for external use.
func (s *Server) GetStatusTracker() *StatusTracker <span class="cov8" title="1">{
        return s.statusTracker
}</span>

// IsReady returns true if the server is ready to handle tool requests.
func (s *Server) IsReady() bool <span class="cov8" title="1">{
        return s.statusTracker.IsReady()
}</span>

</pre>
		
		<pre class="file" id="file7" style="display: none">package mcp

import (
        "sync"
        "time"
)

// IndexingState represents the current state of the indexing process.
type IndexingState int

const (
        // StateUninitialized means indexing hasn't started yet.
        StateUninitialized IndexingState = iota
        // StateIndexing means indexing is in progress.
        StateIndexing
        // StateReady means indexing is complete and server is ready.
        StateReady
        // StateFailed means indexing failed.
        StateFailed
)

// String returns the string representation of the state.
func (s IndexingState) String() string <span class="cov8" title="1">{
        switch s </span>{
        case StateUninitialized:<span class="cov8" title="1">
                return "uninitialized"</span>
        case StateIndexing:<span class="cov8" title="1">
                return "indexing"</span>
        case StateReady:<span class="cov8" title="1">
                return "ready"</span>
        case StateFailed:<span class="cov8" title="1">
                return "failed"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// IndexingPhase represents the current phase of indexing.
type IndexingPhase int

const (
        PhaseNone IndexingPhase = iota
        PhaseParsing
        PhaseModuleRegistry
        PhaseCallGraph
        PhaseComplete
)

// String returns the string representation of the phase.
func (p IndexingPhase) String() string <span class="cov8" title="1">{
        switch p </span>{
        case PhaseNone:<span class="cov8" title="1">
                return "none"</span>
        case PhaseParsing:<span class="cov8" title="1">
                return "parsing"</span>
        case PhaseModuleRegistry:<span class="cov8" title="1">
                return "module_registry"</span>
        case PhaseCallGraph:<span class="cov8" title="1">
                return "call_graph"</span>
        case PhaseComplete:<span class="cov8" title="1">
                return "complete"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// IndexingProgress holds detailed progress information.
type IndexingProgress struct {
        Phase           IndexingPhase `json:"phase"`
        PhaseProgress   float64       `json:"phaseProgress"`   // 0.0 to 1.0
        OverallProgress float64       `json:"overallProgress"` // 0.0 to 1.0
        FilesProcessed  int           `json:"filesProcessed"`
        TotalFiles      int           `json:"totalFiles"`
        CurrentFile     string        `json:"currentFile,omitempty"`
        Message         string        `json:"message,omitempty"`
}

// IndexingStatus holds the complete indexing status.
type IndexingStatus struct {
        State       IndexingState    `json:"state"`
        Progress    IndexingProgress `json:"progress"`
        StartedAt   *time.Time       `json:"startedAt,omitempty"`
        CompletedAt *time.Time       `json:"completedAt,omitempty"`
        Error       string           `json:"error,omitempty"`
        Stats       *IndexingStats   `json:"stats,omitempty"`
}

// IndexingStats holds statistics after indexing completes.
type IndexingStats struct {
        Functions     int           `json:"functions"`
        CallEdges     int           `json:"callEdges"`
        Modules       int           `json:"modules"`
        Files         int           `json:"files"`
        BuildDuration time.Duration `json:"buildDuration"`
}

// StatusTracker tracks and reports indexing status.
type StatusTracker struct {
        mu          sync.RWMutex
        state       IndexingState
        progress    IndexingProgress
        startedAt   *time.Time
        completedAt *time.Time
        errorMsg    string
        stats       *IndexingStats
        subscribers []chan IndexingStatus
}

// NewStatusTracker creates a new status tracker.
func NewStatusTracker() *StatusTracker <span class="cov8" title="1">{
        return &amp;StatusTracker{
                state: StateUninitialized,
                progress: IndexingProgress{
                        Phase: PhaseNone,
                },
        }
}</span>

// GetStatus returns the current indexing status.
func (t *StatusTracker) GetStatus() IndexingStatus <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()

        return IndexingStatus{
                State:       t.state,
                Progress:    t.progress,
                StartedAt:   t.startedAt,
                CompletedAt: t.completedAt,
                Error:       t.errorMsg,
                Stats:       t.stats,
        }
}</span>

// GetState returns the current indexing state.
func (t *StatusTracker) GetState() IndexingState <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.state
}</span>

// IsReady returns true if the server is ready to handle requests.
func (t *StatusTracker) IsReady() bool <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.state == StateReady
}</span>

// StartIndexing marks the start of indexing.
func (t *StatusTracker) StartIndexing() <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        now := time.Now()
        t.state = StateIndexing
        t.startedAt = &amp;now
        t.completedAt = nil
        t.errorMsg = ""
        t.progress = IndexingProgress{
                Phase:           PhaseParsing,
                PhaseProgress:   0,
                OverallProgress: 0,
        }

        t.notifySubscribers()
}</span>

// SetPhase updates the current indexing phase.
func (t *StatusTracker) SetPhase(phase IndexingPhase, message string) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.progress.Phase = phase
        t.progress.PhaseProgress = 0
        t.progress.Message = message

        // Calculate overall progress based on phase.
        switch phase </span>{
        case PhaseParsing:<span class="cov8" title="1">
                t.progress.OverallProgress = 0.0</span>
        case PhaseModuleRegistry:<span class="cov8" title="1">
                t.progress.OverallProgress = 0.33</span>
        case PhaseCallGraph:<span class="cov8" title="1">
                t.progress.OverallProgress = 0.66</span>
        case PhaseComplete:<span class="cov8" title="1">
                t.progress.OverallProgress = 1.0</span>
        }

        <span class="cov8" title="1">t.notifySubscribers()</span>
}

// UpdateProgress updates progress within the current phase.
func (t *StatusTracker) UpdateProgress(processed, total int, currentFile string) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.progress.FilesProcessed = processed
        t.progress.TotalFiles = total
        t.progress.CurrentFile = currentFile

        if total &gt; 0 </span><span class="cov8" title="1">{
                t.progress.PhaseProgress = float64(processed) / float64(total)
        }</span>

        // Update overall progress based on phase + phase progress.
        <span class="cov8" title="1">baseProgress := 0.0
        phaseWeight := 0.33

        switch t.progress.Phase </span>{
        case PhaseParsing:<span class="cov8" title="1">
                baseProgress = 0.0</span>
        case PhaseModuleRegistry:<span class="cov8" title="1">
                baseProgress = 0.33</span>
        case PhaseCallGraph:<span class="cov8" title="1">
                baseProgress = 0.66</span>
        }

        <span class="cov8" title="1">t.progress.OverallProgress = baseProgress + (t.progress.PhaseProgress * phaseWeight)

        t.notifySubscribers()</span>
}

// CompleteIndexing marks indexing as complete.
func (t *StatusTracker) CompleteIndexing(stats *IndexingStats) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        now := time.Now()
        t.state = StateReady
        t.completedAt = &amp;now
        t.stats = stats
        t.progress = IndexingProgress{
                Phase:           PhaseComplete,
                PhaseProgress:   1.0,
                OverallProgress: 1.0,
                Message:         "Indexing complete",
        }

        t.notifySubscribers()
}</span>

// FailIndexing marks indexing as failed.
func (t *StatusTracker) FailIndexing(err error) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        now := time.Now()
        t.state = StateFailed
        t.completedAt = &amp;now
        if err != nil </span><span class="cov8" title="1">{
                t.errorMsg = err.Error()
        }</span>
        <span class="cov8" title="1">t.progress.Message = "Indexing failed"

        t.notifySubscribers()</span>
}

// Subscribe returns a channel that receives status updates.
func (t *StatusTracker) Subscribe() chan IndexingStatus <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        ch := make(chan IndexingStatus, 10)
        t.subscribers = append(t.subscribers, ch)

        // Send current status immediately.
        select </span>{
        case ch &lt;- t.buildStatus():<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov8" title="1">return ch</span>
}

// Unsubscribe removes a subscription channel.
func (t *StatusTracker) Unsubscribe(ch chan IndexingStatus) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        for i, sub := range t.subscribers </span><span class="cov8" title="1">{
                if sub == ch </span><span class="cov8" title="1">{
                        t.subscribers = append(t.subscribers[:i], t.subscribers[i+1:]...)
                        close(ch)
                        break</span>
                }
        }
}

// notifySubscribers sends status to all subscribers (must be called with lock held).
func (t *StatusTracker) notifySubscribers() <span class="cov8" title="1">{
        status := t.buildStatus()
        for _, ch := range t.subscribers </span><span class="cov8" title="1">{
                select </span>{
                case ch &lt;- status:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                        // Channel full, skip.
                }
        }
}

// buildStatus creates status struct (must be called with lock held).
func (t *StatusTracker) buildStatus() IndexingStatus <span class="cov8" title="1">{
        return IndexingStatus{
                State:       t.state,
                Progress:    t.progress,
                StartedAt:   t.startedAt,
                CompletedAt: t.completedAt,
                Error:       t.errorMsg,
                Stats:       t.stats,
        }
}</span>

// GracefulDegradation provides methods for handling requests during indexing.
type GracefulDegradation struct {
        tracker *StatusTracker
}

// NewGracefulDegradation creates a new graceful degradation handler.
func NewGracefulDegradation(tracker *StatusTracker) *GracefulDegradation <span class="cov8" title="1">{
        return &amp;GracefulDegradation{tracker: tracker}
}</span>

// CheckReady checks if the server is ready and returns an appropriate error if not.
func (g *GracefulDegradation) CheckReady() *RPCError <span class="cov8" title="1">{
        status := g.tracker.GetStatus()

        switch status.State </span>{
        case StateReady:<span class="cov8" title="1">
                return nil</span>
        case StateIndexing:<span class="cov8" title="1">
                return IndexNotReadyError(
                        status.Progress.Phase.String(),
                        status.Progress.OverallProgress,
                )</span>
        case StateFailed:<span class="cov8" title="1">
                return InternalError("Indexing failed: " + status.Error)</span>
        default:<span class="cov8" title="1">
                return IndexNotReadyError("uninitialized", 0)</span>
        }
}

// WrapToolCall wraps a tool call with readiness checking.
func (g *GracefulDegradation) WrapToolCall(toolName string, fn func() (string, bool)) (string, bool) <span class="cov8" title="1">{
        if err := g.CheckReady(); err != nil </span><span class="cov8" title="1">{
                return NewToolError(err.Message, err.Code, map[string]interface{}{
                        "tool":   toolName,
                        "status": g.tracker.GetStatus(),
                }), true
        }</span>
        <span class="cov8" title="1">return fn()</span>
}

// GetStatusJSON returns the current status as a JSON-friendly map.
func (g *GracefulDegradation) GetStatusJSON() map[string]interface{} <span class="cov8" title="1">{
        status := g.tracker.GetStatus()

        result := map[string]interface{}{
                "state": status.State.String(),
                "progress": map[string]interface{}{
                        "phase":           status.Progress.Phase.String(),
                        "phaseProgress":   status.Progress.PhaseProgress,
                        "overallProgress": status.Progress.OverallProgress,
                        "filesProcessed":  status.Progress.FilesProcessed,
                        "totalFiles":      status.Progress.TotalFiles,
                },
        }

        if status.Progress.CurrentFile != "" </span><span class="cov8" title="1">{
                result["progress"].(map[string]interface{})["currentFile"] = status.Progress.CurrentFile
        }</span>

        <span class="cov8" title="1">if status.Progress.Message != "" </span><span class="cov8" title="1">{
                result["progress"].(map[string]interface{})["message"] = status.Progress.Message
        }</span>

        <span class="cov8" title="1">if status.StartedAt != nil </span><span class="cov8" title="1">{
                result["startedAt"] = status.StartedAt.Format(time.RFC3339)
        }</span>

        <span class="cov8" title="1">if status.CompletedAt != nil </span><span class="cov8" title="1">{
                result["completedAt"] = status.CompletedAt.Format(time.RFC3339)
        }</span>

        <span class="cov8" title="1">if status.Error != "" </span><span class="cov8" title="1">{
                result["error"] = status.Error
        }</span>

        <span class="cov8" title="1">if status.Stats != nil </span><span class="cov8" title="1">{
                result["stats"] = map[string]interface{}{
                        "functions":     status.Stats.Functions,
                        "callEdges":     status.Stats.CallEdges,
                        "modules":       status.Stats.Modules,
                        "files":         status.Stats.Files,
                        "buildDuration": status.Stats.BuildDuration.String(),
                }
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package mcp

import (
        "encoding/json"
        "fmt"
        "strings"

        "github.com/shivasurya/code-pathfinder/sast-engine/graph/callgraph/registry"
)

// getToolDefinitions returns the complete tool schemas.
func (s *Server) getToolDefinitions() []Tool <span class="cov8" title="1">{
        return []Tool{
                {
                        Name: "get_index_info",
                        Description: `Get statistics about the indexed Python codebase. Use this FIRST to understand the project scope before making other queries.

Returns: project_path, python_version, indexed_at timestamp, build_time, and stats (functions count, call_edges count, modules count, files count, taint_summaries count).

Use when: Starting analysis, understanding project size, or verifying the index is built correctly.`,
                        InputSchema: InputSchema{
                                Type:       "object",
                                Properties: map[string]Property{},
                        },
                },
                {
                        Name: "find_symbol",
                        Description: `Search for functions, classes, methods, or class attributes by name. Supports partial matching. Results are paginated.

Returns: List of matches with FQN (fully qualified name like 'myapp.auth.login' or 'myapp.User.email'), file path, line number, type, and metadata. For functions/methods: return_type, parameters, decorators, superclass. For class fields: inferred_type, confidence, assigned_in. Includes pagination info.

Use when: Looking for a specific function, class, or attribute; exploring what symbols exist; or finding where something is defined.

Examples:
- find_symbol("login") - finds all functions containing 'login'
- find_symbol("authenticate_user") - finds exact function
- find_symbol("myapp.auth") - finds all symbols in auth module`,
                        InputSchema: InputSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "name":   {Type: "string", Description: "Symbol name to find. Can be: short name ('login'), partial name ('auth'), or FQN ('myapp.auth.login')"},
                                        "limit":  {Type: "integer", Description: "Max results to return (default: 50, max: 500)"},
                                        "cursor": {Type: "string", Description: "Pagination cursor from previous response"},
                                },
                                Required: []string{"name"},
                        },
                },
                {
                        Name: "get_callers",
                        Description: `Find all functions that CALL a given function (reverse call graph / incoming edges). Answer: "Who uses this function?" Results are paginated.

Returns: Target function info and list of callers with their FQN, file, line number, and the specific call site location. Includes pagination info.

Use when: Understanding function usage, impact analysis before refactoring, finding entry points, or tracing how data flows INTO a function.

Examples:
- get_callers("sanitize_input") - who calls the sanitize function?
- get_callers("database.execute") - what code runs database queries?`,
                        InputSchema: InputSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "function": {Type: "string", Description: "Function to find callers for. Use short name ('login') or FQN ('myapp.auth.login')"},
                                        "limit":    {Type: "integer", Description: "Max results to return (default: 50, max: 500)"},
                                        "cursor":   {Type: "string", Description: "Pagination cursor from previous response"},
                                },
                                Required: []string{"function"},
                        },
                },
                {
                        Name: "get_callees",
                        Description: `Find all functions CALLED BY a given function (forward call graph / outgoing edges). Answer: "What does this function depend on?" Results are paginated.

Returns: Source function info, list of callees with target name, call line, resolution status (resolved/unresolved), and type inference info if available. Includes pagination info.

Use when: Understanding function dependencies, analyzing what a function does, tracing data flow FROM a function, or finding unresolved external calls.

Examples:
- get_callees("process_payment") - what functions does payment processing call?
- get_callees("handle_request") - what are the dependencies of the request handler?`,
                        InputSchema: InputSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "function": {Type: "string", Description: "Function to find callees for. Use short name ('process') or FQN ('myapp.payment.process')"},
                                        "limit":    {Type: "integer", Description: "Max results to return (default: 50, max: 500)"},
                                        "cursor":   {Type: "string", Description: "Pagination cursor from previous response"},
                                },
                                Required: []string{"function"},
                        },
                },
                {
                        Name: "get_call_details",
                        Description: `Get detailed information about a SPECIFIC call from one function to another. Most detailed view of a single call site.

Returns: Full call site info including caller FQN, target, exact location (file, line, column), arguments passed, and resolution details (resolved status, failure reason if unresolved, type inference info).

Use when: Investigating a specific function call, understanding how arguments are passed, debugging why a call wasn't resolved, or analyzing type inference.

Examples:
- get_call_details("handle_request", "authenticate") - how does handle_request call authenticate?
- get_call_details("save_user", "execute") - examine the database call in save_user`,
                        InputSchema: InputSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "caller": {Type: "string", Description: "The function making the call (short name or FQN)"},
                                        "callee": {Type: "string", Description: "The function being called (short name, will match partially)"},
                                },
                                Required: []string{"caller", "callee"},
                        },
                },
                {
                        Name: "resolve_import",
                        Description: `Resolve a Python import path to its actual file location in the project.

Returns: Import resolution with file_path, module_fqn, match_type (exact/short_name/partial/ambiguous), and alternatives if multiple matches exist.

Use when: Finding where a module is defined, understanding import structure, or locating source files for external references.

Examples:
- resolve_import("myapp.auth.users") - find the users module
- resolve_import("utils") - find modules named utils (may return multiple)
- resolve_import("database") - locate database module`,
                        InputSchema: InputSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "import": {Type: "string", Description: "Import path to resolve. Can be FQN ('myapp.auth.users') or short name ('users')"},
                                },
                                Required: []string{"import"},
                        },
                },
        }
}</span>

// executeTool runs a tool and returns the result.
func (s *Server) executeTool(name string, args map[string]interface{}) (string, bool) <span class="cov8" title="1">{
        switch name </span>{
        case "get_index_info":<span class="cov8" title="1">
                return s.toolGetIndexInfo()</span>
        case "find_symbol":<span class="cov8" title="1">
                return s.toolFindSymbol(args)</span>
        case "get_callers":<span class="cov8" title="1">
                return s.toolGetCallers(args)</span>
        case "get_callees":<span class="cov8" title="1">
                return s.toolGetCallees(args)</span>
        case "get_call_details":<span class="cov8" title="1">
                caller, _ := args["caller"].(string)
                callee, _ := args["callee"].(string)
                return s.toolGetCallDetails(caller, callee)</span>
        case "resolve_import":<span class="cov8" title="1">
                importPath, _ := args["import"].(string)
                return s.toolResolveImport(importPath)</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf(`{"error": "Unknown tool: %s"}`, name), true</span>
        }
}

// ============================================================================
// Tool Implementations
// ============================================================================

// toolGetIndexInfo returns index statistics.
func (s *Server) toolGetIndexInfo() (string, bool) <span class="cov8" title="1">{
        result := map[string]interface{}{
                "project_path":       s.projectPath,
                "python_version":     s.pythonVersion,
                "indexed_at":         s.indexedAt.Format("2006-01-02T15:04:05Z07:00"),
                "build_time_seconds": s.buildTime.Seconds(),
                "stats": map[string]int{
                        "functions":       len(s.callGraph.Functions),
                        "call_edges":      len(s.callGraph.Edges),
                        "modules":         len(s.moduleRegistry.Modules),
                        "files":           len(s.moduleRegistry.FileToModule),
                        "taint_summaries": len(s.callGraph.Summaries),
                },
        }
        bytes, _ := json.MarshalIndent(result, "", "  ")
        return string(bytes), false
}</span>

// toolFindSymbol finds symbols by name with pagination support.
// Searches both functions/methods/classes AND class attributes/fields.
func (s *Server) toolFindSymbol(args map[string]interface{}) (string, bool) <span class="cov8" title="1">{
        name, _ := args["name"].(string)
        if name == "" </span><span class="cov8" title="1">{
                return `{"error": "name parameter is required"}`, true
        }</span>

        // Extract pagination params.
        <span class="cov8" title="1">pageParams, err := ExtractPaginationParams(args)
        if err != nil </span><span class="cov0" title="0">{
                return NewToolError(err.Message, err.Code, err.Data), true
        }</span>

        <span class="cov8" title="1">var allMatches []map[string]interface{}

        // Search functions, methods, and classes.
        for fqn, node := range s.callGraph.Functions </span><span class="cov8" title="1">{
                shortName := getShortName(fqn)
                if shortName == name || strings.HasSuffix(fqn, "."+name) || fqn == name || strings.Contains(fqn, name) </span><span class="cov8" title="1">{
                        match := map[string]interface{}{
                                "fqn":  fqn,
                                "file": node.File,
                                "line": node.LineNumber,
                                "type": node.Type,
                        }

                        // Add optional fields if available.
                        if node.ReturnType != "" </span><span class="cov8" title="1">{
                                match["return_type"] = node.ReturnType
                        }</span>
                        <span class="cov8" title="1">if len(node.MethodArgumentsType) &gt; 0 </span><span class="cov8" title="1">{
                                match["parameters"] = node.MethodArgumentsType
                        }</span>
                        <span class="cov8" title="1">if node.Modifier != "" </span><span class="cov8" title="1">{
                                match["modifier"] = node.Modifier
                        }</span>
                        <span class="cov8" title="1">if len(node.Annotation) &gt; 0 </span><span class="cov8" title="1">{
                                match["decorators"] = node.Annotation
                        }</span>
                        <span class="cov8" title="1">if node.SuperClass != "" </span><span class="cov8" title="1">{
                                match["superclass"] = node.SuperClass
                        }</span>

                        <span class="cov8" title="1">allMatches = append(allMatches, match)</span>
                }
        }

        // Search class attributes if AttributeRegistry is available.
        <span class="cov8" title="1">if s.callGraph.Attributes != nil </span><span class="cov8" title="1">{
                if attrRegistry, ok := s.callGraph.Attributes.(*registry.AttributeRegistry); ok </span><span class="cov8" title="1">{
                        for classFQN, classAttrs := range attrRegistry.Classes </span><span class="cov8" title="1">{
                                for attrName, attr := range classAttrs.Attributes </span><span class="cov8" title="1">{
                                        // Match attribute name (simple or qualified).
                                        attributeFQN := classFQN + "." + attrName
                                        if attrName == name || strings.Contains(attrName, name) ||
                                           strings.HasSuffix(attributeFQN, "."+name) ||
                                           strings.Contains(attributeFQN, name) </span><span class="cov8" title="1">{
                                                match := map[string]interface{}{
                                                        "fqn":   attributeFQN,
                                                        "type":  "class_field",
                                                        "class": classFQN,
                                                        "name":  attrName,
                                                }

                                                // Add location if available.
                                                if attr.Location != nil </span><span class="cov8" title="1">{
                                                        match["file"] = attr.Location.File
                                                        // Note: SourceLocation uses byte offsets, not line numbers.
                                                        // Could convert but would require reading file - skip for now.
                                                }</span>

                                                // Add type information if available.
                                                <span class="cov8" title="1">if attr.Type != nil &amp;&amp; attr.Type.TypeFQN != "" </span><span class="cov8" title="1">{
                                                        match["inferred_type"] = attr.Type.TypeFQN
                                                        match["confidence"] = attr.Confidence
                                                }</span>

                                                // Add assignment location.
                                                <span class="cov8" title="1">if attr.AssignedIn != "" </span><span class="cov8" title="1">{
                                                        match["assigned_in"] = attr.AssignedIn
                                                }</span>

                                                <span class="cov8" title="1">allMatches = append(allMatches, match)</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">if len(allMatches) == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf(`{"error": "Symbol not found: %s", "suggestion": "Try a partial name or check spelling"}`, name), true
        }</span>

        // Apply pagination.
        <span class="cov8" title="1">matches, pageInfo := PaginateSlice(allMatches, pageParams)

        result := map[string]interface{}{
                "query":      name,
                "matches":    matches,
                "pagination": pageInfo,
        }
        bytes, _ := json.MarshalIndent(result, "", "  ")
        return string(bytes), false</span>
}

// toolGetCallers finds all callers of a function with pagination support.
func (s *Server) toolGetCallers(args map[string]interface{}) (string, bool) <span class="cov8" title="1">{
        function, _ := args["function"].(string)
        if function == "" </span><span class="cov8" title="1">{
                return `{"error": "function parameter is required"}`, true
        }</span>

        // Extract pagination params.
        <span class="cov8" title="1">pageParams, err := ExtractPaginationParams(args)
        if err != nil </span><span class="cov0" title="0">{
                return NewToolError(err.Message, err.Code, err.Data), true
        }</span>

        <span class="cov8" title="1">fqns := s.findMatchingFQNs(function)
        if len(fqns) == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf(`{"error": "Function not found: %s"}`, function), true
        }</span>

        // Use first match.
        <span class="cov8" title="1">targetFQN := fqns[0]
        targetNode := s.callGraph.Functions[targetFQN]

        // Get callers from reverse edges.
        callerFQNs := s.callGraph.ReverseEdges[targetFQN]

        allCallers := make([]map[string]interface{}, 0, len(callerFQNs))
        for _, callerFQN := range callerFQNs </span><span class="cov8" title="1">{
                callerNode := s.callGraph.Functions[callerFQN]
                if callerNode == nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">caller := map[string]interface{}{
                        "fqn":  callerFQN,
                        "name": getShortName(callerFQN),
                        "file": callerNode.File,
                        "line": callerNode.LineNumber,
                }

                // Find the specific call site location.
                for _, cs := range s.callGraph.CallSites[callerFQN] </span><span class="cov8" title="1">{
                        if cs.TargetFQN == targetFQN || cs.Target == getShortName(targetFQN) </span><span class="cov8" title="1">{
                                caller["call_line"] = cs.Location.Line
                                caller["call_column"] = cs.Location.Column
                                break</span>
                        }
                }

                <span class="cov8" title="1">allCallers = append(allCallers, caller)</span>
        }

        // Apply pagination.
        <span class="cov8" title="1">callers, pageInfo := PaginateSlice(allCallers, pageParams)

        result := map[string]interface{}{
                "target": map[string]interface{}{
                        "fqn":  targetFQN,
                        "name": getShortName(targetFQN),
                        "file": targetNode.File,
                        "line": targetNode.LineNumber,
                },
                "callers":    callers,
                "pagination": pageInfo,
        }

        if len(fqns) &gt; 1 </span><span class="cov8" title="1">{
                result["note"] = fmt.Sprintf("Multiple matches found (%d). Showing callers for first match. Other matches: %v", len(fqns), fqns[1:])
        }</span>

        <span class="cov8" title="1">bytes, _ := json.MarshalIndent(result, "", "  ")
        return string(bytes), false</span>
}

// toolGetCallees finds all functions called by a function.
func (s *Server) toolGetCallees(args map[string]interface{}) (string, bool) <span class="cov8" title="1">{
        function, _ := args["function"].(string)
        if function == "" </span><span class="cov8" title="1">{
                return `{"error": "function parameter is required"}`, true
        }</span>

        // Extract pagination params.
        <span class="cov8" title="1">pageParams, rpcErr := ExtractPaginationParams(args)
        if rpcErr != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf(`{"error": "%s"}`, rpcErr.Message), true
        }</span>

        <span class="cov8" title="1">fqns := s.findMatchingFQNs(function)
        if len(fqns) == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf(`{"error": "Function not found: %s"}`, function), true
        }</span>

        <span class="cov8" title="1">sourceFQN := fqns[0]
        sourceNode := s.callGraph.Functions[sourceFQN]

        // Get call sites for this function.
        callSites := s.callGraph.CallSites[sourceFQN]

        allCallees := make([]map[string]interface{}, 0, len(callSites))
        resolvedCount := 0
        unresolvedCount := 0

        for _, cs := range callSites </span><span class="cov8" title="1">{
                callee := map[string]interface{}{
                        "target":    cs.Target,
                        "call_line": cs.Location.Line,
                        "resolved":  cs.Resolved,
                }

                if cs.Resolved </span><span class="cov8" title="1">{
                        resolvedCount++
                        callee["target_fqn"] = cs.TargetFQN

                        // Try to get file info for resolved target.
                        if targetNode := s.callGraph.Functions[cs.TargetFQN]; targetNode != nil </span><span class="cov8" title="1">{
                                callee["target_file"] = targetNode.File
                                callee["target_line"] = targetNode.LineNumber
                        }</span>
                } else<span class="cov8" title="1"> {
                        unresolvedCount++
                        if cs.FailureReason != "" </span><span class="cov8" title="1">{
                                callee["failure_reason"] = cs.FailureReason
                        }</span>
                }

                // Include type inference info if used.
                <span class="cov8" title="1">if cs.ResolvedViaTypeInference </span><span class="cov8" title="1">{
                        callee["type_inference"] = map[string]interface{}{
                                "inferred_type":   cs.InferredType,
                                "type_confidence": cs.TypeConfidence,
                        }
                }</span>

                <span class="cov8" title="1">allCallees = append(allCallees, callee)</span>
        }

        // Apply pagination.
        <span class="cov8" title="1">callees, pageInfo := PaginateSlice(allCallees, pageParams)

        result := map[string]interface{}{
                "source": map[string]interface{}{
                        "fqn":  sourceFQN,
                        "name": getShortName(sourceFQN),
                        "file": sourceNode.File,
                        "line": sourceNode.LineNumber,
                },
                "callees":          callees,
                "pagination":       pageInfo,
                "resolved_count":   resolvedCount,
                "unresolved_count": unresolvedCount,
        }

        bytes, _ := json.MarshalIndent(result, "", "  ")
        return string(bytes), false</span>
}

// toolGetCallDetails gets detailed info about a specific call site.
func (s *Server) toolGetCallDetails(callerName, calleeName string) (string, bool) <span class="cov8" title="1">{
        if callerName == "" || calleeName == "" </span><span class="cov8" title="1">{
                return `{"error": "caller and callee parameters are required"}`, true
        }</span>

        <span class="cov8" title="1">callerFQNs := s.findMatchingFQNs(callerName)
        if len(callerFQNs) == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf(`{"error": "Caller function not found: %s"}`, callerName), true
        }</span>

        <span class="cov8" title="1">callerFQN := callerFQNs[0]
        callSites := s.callGraph.CallSites[callerFQN]

        // Find matching call site.
        for _, cs := range callSites </span><span class="cov8" title="1">{
                if strings.Contains(cs.Target, calleeName) || strings.Contains(cs.TargetFQN, calleeName) </span><span class="cov8" title="1">{
                        callSite := map[string]interface{}{
                                "caller_fqn": callerFQN,
                                "target":     cs.Target,
                                "target_fqn": cs.TargetFQN,
                                "location": map[string]interface{}{
                                        "file":   cs.Location.File,
                                        "line":   cs.Location.Line,
                                        "column": cs.Location.Column,
                                },
                                "resolved": cs.Resolved,
                        }

                        // Add arguments if available.
                        if len(cs.Arguments) &gt; 0 </span><span class="cov8" title="1">{
                                args := make([]map[string]interface{}, len(cs.Arguments))
                                for i, arg := range cs.Arguments </span><span class="cov8" title="1">{
                                        args[i] = map[string]interface{}{
                                                "position": arg.Position,
                                                "value":    arg.Value,
                                        }
                                }</span>
                                <span class="cov8" title="1">callSite["arguments"] = args</span>
                        }

                        // Add resolution info.
                        <span class="cov8" title="1">resolution := map[string]interface{}{
                                "resolved": cs.Resolved,
                        }
                        if !cs.Resolved &amp;&amp; cs.FailureReason != "" </span><span class="cov8" title="1">{
                                resolution["failure_reason"] = cs.FailureReason
                        }</span>
                        <span class="cov8" title="1">if cs.ResolvedViaTypeInference </span><span class="cov8" title="1">{
                                resolution["via_type_inference"] = true
                                resolution["inferred_type"] = cs.InferredType
                                resolution["type_confidence"] = cs.TypeConfidence
                                resolution["type_source"] = cs.TypeSource
                        }</span>
                        <span class="cov8" title="1">callSite["resolution"] = resolution

                        result := map[string]interface{}{
                                "call_site": callSite,
                        }
                        bytes, _ := json.MarshalIndent(result, "", "  ")
                        return string(bytes), false</span>
                }
        }

        <span class="cov8" title="1">return fmt.Sprintf(`{"error": "Call site not found: %s -&gt; %s", "suggestion": "Check that the caller actually calls the callee"}`, callerName, calleeName), true</span>
}

// toolResolveImport resolves an import path to file location.
func (s *Server) toolResolveImport(importPath string) (string, bool) <span class="cov8" title="1">{
        if importPath == "" </span><span class="cov8" title="1">{
                return `{"error": "import parameter is required"}`, true
        }</span>

        // Try exact match first.
        <span class="cov8" title="1">if filePath, ok := s.moduleRegistry.Modules[importPath]; ok </span><span class="cov8" title="1">{
                result := map[string]interface{}{
                        "import":       importPath,
                        "resolved":     true,
                        "file_path":    filePath,
                        "module_fqn":   importPath,
                        "match_type":   "exact",
                        "alternatives": []interface{}{},
                }
                bytes, _ := json.MarshalIndent(result, "", "  ")
                return string(bytes), false
        }</span>

        // Try short name lookup.
        <span class="cov8" title="1">shortName := getShortName(importPath)
        if files, ok := s.moduleRegistry.ShortNames[shortName]; ok &amp;&amp; len(files) &gt; 0 </span><span class="cov8" title="1">{
                if len(files) == 1 </span><span class="cov8" title="1">{
                        // Unique match.
                        filePath := files[0]
                        moduleFQN := s.moduleRegistry.FileToModule[filePath]
                        result := map[string]interface{}{
                                "import":       importPath,
                                "resolved":     true,
                                "file_path":    filePath,
                                "module_fqn":   moduleFQN,
                                "match_type":   "short_name",
                                "alternatives": []interface{}{},
                        }
                        bytes, _ := json.MarshalIndent(result, "", "  ")
                        return string(bytes), false
                }</span>

                // Multiple matches - return alternatives.
                <span class="cov8" title="1">alternatives := make([]map[string]string, len(files))
                for i, f := range files </span><span class="cov8" title="1">{
                        alternatives[i] = map[string]string{
                                "fqn":  s.moduleRegistry.FileToModule[f],
                                "file": f,
                        }
                }</span>
                <span class="cov8" title="1">result := map[string]interface{}{
                        "import":       importPath,
                        "resolved":     false,
                        "match_type":   "ambiguous",
                        "alternatives": alternatives,
                        "suggestion":   "Multiple modules match. Use fully qualified import path.",
                }
                bytes, _ := json.MarshalIndent(result, "", "  ")
                return string(bytes), false</span>
        }

        // Try partial match.
        <span class="cov8" title="1">var partialMatches []map[string]string
        for moduleFQN, filePath := range s.moduleRegistry.Modules </span><span class="cov8" title="1">{
                if strings.Contains(moduleFQN, importPath) </span><span class="cov8" title="1">{
                        partialMatches = append(partialMatches, map[string]string{
                                "fqn":  moduleFQN,
                                "file": filePath,
                        })
                }</span>
        }

        <span class="cov8" title="1">if len(partialMatches) &gt; 0 </span><span class="cov8" title="1">{
                result := map[string]interface{}{
                        "import":       importPath,
                        "resolved":     false,
                        "match_type":   "partial",
                        "alternatives": partialMatches,
                        "suggestion":   "No exact match. Did you mean one of these?",
                }
                bytes, _ := json.MarshalIndent(result, "", "  ")
                return string(bytes), false
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf(`{"error": "Import not found: %s", "suggestion": "Check if the module is in the indexed project path"}`, importPath), true</span>
}

// ============================================================================
// Helper Functions
// ============================================================================

// findMatchingFQNs finds all FQNs matching a name.
func (s *Server) findMatchingFQNs(name string) []string <span class="cov8" title="1">{
        var matches []string
        for fqn := range s.callGraph.Functions </span><span class="cov8" title="1">{
                shortName := getShortName(fqn)
                if shortName == name || strings.HasSuffix(fqn, "."+name) || fqn == name </span><span class="cov8" title="1">{
                        matches = append(matches, fqn)
                }</span>
        }
        <span class="cov8" title="1">return matches</span>
}

// getShortName extracts the last part of a FQN.
func getShortName(fqn string) string <span class="cov8" title="1">{
        parts := strings.Split(fqn, ".")
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return fqn
        }</span>
        <span class="cov8" title="1">return parts[len(parts)-1]</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package mcp

import "encoding/json"

// ============================================================================
// JSON-RPC 2.0 Types
// ============================================================================

// JSONRPCRequest represents a JSON-RPC 2.0 request.
type JSONRPCRequest struct {
        JSONRPC string          `json:"jsonrpc"`
        ID      interface{}     `json:"id"`
        Method  string          `json:"method"`
        Params  json.RawMessage `json:"params,omitempty"`
}

// JSONRPCResponse represents a JSON-RPC 2.0 response.
type JSONRPCResponse struct {
        JSONRPC string      `json:"jsonrpc"`
        ID      interface{} `json:"id"`
        Result  interface{} `json:"result,omitempty"`
        Error   *RPCError   `json:"error,omitempty"`
}

// RPCError represents a JSON-RPC 2.0 error.
type RPCError struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
}

// ============================================================================
// MCP Protocol Types
// ============================================================================

// InitializeParams contains initialization parameters from the client.
type InitializeParams struct {
        ProtocolVersion string     `json:"protocolVersion"`
        ClientInfo      ClientInfo `json:"clientInfo"`
}

// ClientInfo identifies the MCP client.
type ClientInfo struct {
        Name    string `json:"name"`
        Version string `json:"version"`
}

// InitializeResult is returned to the client after initialization.
type InitializeResult struct {
        ProtocolVersion string       `json:"protocolVersion"`
        ServerInfo      ServerInfo   `json:"serverInfo"`
        Capabilities    Capabilities `json:"capabilities"`
}

// ServerInfo identifies this MCP server.
type ServerInfo struct {
        Name    string `json:"name"`
        Version string `json:"version"`
}

// Capabilities advertises server features.
type Capabilities struct {
        Tools *ToolsCapability `json:"tools,omitempty"`
}

// ToolsCapability describes tool support capabilities.
type ToolsCapability struct {
        ListChanged bool `json:"listChanged,omitempty"`
}

// ============================================================================
// Tool Types
// ============================================================================

// Tool defines a tool for tools/list response.
type Tool struct {
        Name        string      `json:"name"`
        Description string      `json:"description"`
        InputSchema InputSchema `json:"inputSchema"`
}

// InputSchema describes tool parameters.
type InputSchema struct {
        Type       string              `json:"type"`
        Properties map[string]Property `json:"properties,omitempty"`
        Required   []string            `json:"required,omitempty"`
}

// Property describes a single parameter.
type Property struct {
        Type        string `json:"type"`
        Description string `json:"description"`
}

// ToolsListResult is returned for tools/list requests.
type ToolsListResult struct {
        Tools []Tool `json:"tools"`
}

// ToolCallParams contains parameters for tools/call requests.
type ToolCallParams struct {
        Name      string                 `json:"name"`
        Arguments map[string]interface{} `json:"arguments,omitempty"`
}

// ToolResult is returned for tools/call responses.
type ToolResult struct {
        Content []ContentBlock `json:"content"`
        IsError bool           `json:"isError,omitempty"`
}

// ContentBlock represents a content block for tool output.
type ContentBlock struct {
        Type string `json:"type"`
        Text string `json:"text"`
}

// ============================================================================
// Helper Functions
// ============================================================================

// SuccessResponse creates a successful JSON-RPC response.
func SuccessResponse(id interface{}, result interface{}) *JSONRPCResponse <span class="cov8" title="1">{
        return &amp;JSONRPCResponse{
                JSONRPC: "2.0",
                ID:      id,
                Result:  result,
        }
}</span>

// ErrorResponse creates an error JSON-RPC response.
func ErrorResponse(id interface{}, code int, message string) *JSONRPCResponse <span class="cov8" title="1">{
        return &amp;JSONRPCResponse{
                JSONRPC: "2.0",
                ID:      id,
                Error:   &amp;RPCError{Code: code, Message: message},
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
