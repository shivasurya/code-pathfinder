import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import {
  WorkspaceAnalyzer,
  ApplicationProfile
} from '@codepathfinder/secureflow-cli';
import { SettingsManager } from '../settings/settings-manager';

/**
 * TODO(CLI): This module imports VS Code types and uses vscode.WorkspaceFolder.
 * Refactor plan to enable CLI reuse:
 * - Introduce a CLI-friendly constructor overload that accepts `rootPath: string` instead of
 *   `vscode.WorkspaceFolder`, and avoid direct `vscode` dependency in core logic.
 * - Keep the current class as EXTENSION adapter: it will pass `workspaceFolder.uri.fsPath`
 *   into a pure profiler that uses only Node's fs/path and AI client.
 * - The following remain extension-only: anything reading `vscode.workspace` or using VS Code UI.
 */
// ApplicationProfile is now imported from the CLI library
export { ApplicationProfile } from '@codepathfinder/secureflow-cli';

/**
 * Helper class for analyzing the current workspace to determine project type
 */
export class ProjectProfiler {
  // Files that would signal automatic generation (to be skipped)
  private readonly autoGeneratedFilePatterns = [
    '.git',
    'node_modules',
    'dist',
    'build',
    '.next',
    '.cache',
    'coverage',
    '__pycache__',
    '*.min.js',
    '*.min.css',
    '*.lock',
    'package-lock.json',
    'yarn.lock',
    'pnpm-lock.yaml'
  ];

  // Key project files that provide strong signals about project type
  private readonly projectSignalFiles = [
    'package.json',
    'tsconfig.json',
    'angular.json',
    'next.config.js',
    'nuxt.config.js',
    'vite.config.js',
    'webpack.config.js',
    'AndroidManifest.xml',
    'Info.plist',
    'Podfile',
    'pubspec.yaml',
    'setup.py',
    'requirements.txt',
    'pyproject.toml',
    'Cargo.toml',
    'pom.xml',
    'build.gradle',
    'Dockerfile',
    'docker-compose.yml',
    'serverless.yml',
    'app.yaml',
    '.csproj',
    '.fsproj'
  ];

  // Maximum file size to read (1MB)
  private readonly maxFileSize = 1024 * 1024;

  // Maximum depth to traverse in directories
  private readonly maxTraversalDepth = 4;

  // Workspace analyzer for AI-based profiling
  private workspaceAnalyzer: WorkspaceAnalyzer;

  constructor(
    private readonly workspaceFolder: vscode.WorkspaceFolder,
    private readonly settingsManager?: SettingsManager
  ) {
    // Initialize workspace analyzer
    const selectedModel =
      this.settingsManager?.getSelectedAIModel() ||
      'claude-sonnet-4-5-20250929';
    this.workspaceAnalyzer = new WorkspaceAnalyzer({ selectedModel });
  }

  /**
   * Profile the workspace and detect application types
   */
  public async profileWorkspace(
    secretApiKey: string,
    progressCallback?: (message: string) => void
  ): Promise<ApplicationProfile[]> {
    try {
      // First collect the project structure
      progressCallback?.('Collecting project structure...');
      const projectStructure =
        await this.collectProjectStructure(progressCallback);

      // Next, read critical files for deeper analysis
      progressCallback?.('Analyzing key project files...');
      const keyFileContents = await this.readKeyProjectFiles(projectStructure);

      // Use AI to determine the project type
      progressCallback?.('Determining project type...');
      const applicationProfiles =
        await this.workspaceAnalyzer.determineProjectTypes(
          projectStructure,
          keyFileContents,
          secretApiKey,
          progressCallback
        );

      return applicationProfiles;
    } catch (error) {
      console.error('Error profiling workspace:', error);
      throw error;
    }
  }

  /**
   * Collect the basic project structure (directories and files)
   */
  private async collectProjectStructure(
    progressCallback?: (message: string) => void
  ): Promise<any> {
    const rootPath = this.workspaceFolder.uri.fsPath;
    progressCallback?.(`Scanning project structure at: ${rootPath}`);
    const structure: any = {
      rootPath,
      directories: [],
      files: []
    };

    await this.traverseDirectory(rootPath, structure, 0);

    // Return the collected structure
    if (progressCallback) {
      progressCallback(
        `Project structure collected with ${structure.directories.length} directories and ${structure.files.length} files.`
      );
    }
    return structure;
  }

  /**
   * Recursively traverse the directory to build the project structure
   */
  private async traverseDirectory(
    dirPath: string,
    structure: any,
    depth: number
  ): Promise<void> {
    if (depth > this.maxTraversalDepth) {
      return;
    }

    try {
      const entries = fs.readdirSync(dirPath, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dirPath, entry.name);
        const relativePath = path.relative(
          this.workspaceFolder.uri.fsPath,
          fullPath
        );

        // Skip auto-generated files and directories
        if (this.shouldSkip(entry.name, relativePath)) {
          continue;
        }

        if (entry.isDirectory()) {
          structure.directories.push({
            name: entry.name,
            path: relativePath,
            depth
          });

          // Recursively traverse subdirectories
          await this.traverseDirectory(fullPath, structure, depth + 1);
        } else if (entry.isFile()) {
          structure.files.push({
            name: entry.name,
            path: relativePath,
            extension: path.extname(entry.name).toLowerCase(),
            size: fs.statSync(fullPath).size
          });
        }
      }
    } catch (error) {
      console.error(`Error traversing directory ${dirPath}:`, error);
    }
  }

  /**
   * Check if a file or directory should be skipped
   */
  private shouldSkip(name: string, relativePath: string): boolean {
    // Check if it matches any auto-generated patterns
    for (const pattern of this.autoGeneratedFilePatterns) {
      if (pattern.startsWith('*.')) {
        // Extension pattern
        const ext = pattern.substring(1);
        if (name.endsWith(ext)) {
          return true;
        }
      } else if (name === pattern || relativePath.includes(pattern)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Read contents of key project files for deeper analysis
   */
  private async readKeyProjectFiles(projectStructure: any): Promise<any[]> {
    const keyFiles: any[] = [];

    for (const file of projectStructure.files) {
      if (this.isKeyProjectFile(file.name)) {
        try {
          const fullPath = path.join(
            this.workspaceFolder.uri.fsPath,
            file.path
          );
          const stats = fs.statSync(fullPath);

          // Skip files that are too large
          if (stats.size > this.maxFileSize) {
            keyFiles.push({
              name: file.name,
              path: file.path,
              content: '[File too large to include]'
            });
            continue;
          }

          const content = fs.readFileSync(fullPath, 'utf8');
          keyFiles.push({
            name: file.name,
            path: file.path,
            content
          });
        } catch (error) {
          console.error(`Error reading file ${file.path}:`, error);
        }
      }
    }

    return keyFiles;
  }

  /**
   * Check if a file is a key project file
   */
  private isKeyProjectFile(fileName: string): boolean {
    return this.projectSignalFiles.includes(fileName);
  }
}

export default ProjectProfiler;
