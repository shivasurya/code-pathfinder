import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { AIClientFactory } from '../clients';
import { AIClient } from '../clients/ai-client';
import { loadPrompt } from '../prompts/prompt-loader';
import { SettingsManager } from '../settings/settings-manager';

/**
 * Interface representing a detected application in the workspace
 */
export interface ApplicationProfile {
  name: string;
  path: string;
  category: string;
  subcategory?: string;
  technology?: string;
  confidence: number;
  languages: string[];
  frameworks: string[];
  buildTools: string[];
  evidence: string[];
}

/**
 * Helper class for analyzing the current workspace to determine project type
 */
export class ProjectProfiler {
  // Files that would signal automatic generation (to be skipped)
  private readonly autoGeneratedFilePatterns = [
    '.git',
    'node_modules',
    'dist',
    'build',
    '.next',
    '.cache',
    'coverage',
    '__pycache__',
    '*.min.js',
    '*.min.css',
    '*.lock',
    'package-lock.json',
    'yarn.lock',
    'pnpm-lock.yaml'
  ];

  // Key project files that provide strong signals about project type
  private readonly projectSignalFiles = [
    'package.json',
    'tsconfig.json',
    'angular.json',
    'next.config.js',
    'nuxt.config.js',
    'vite.config.js',
    'webpack.config.js',
    'AndroidManifest.xml',
    'Info.plist',
    'Podfile',
    'pubspec.yaml',
    'setup.py',
    'requirements.txt',
    'pyproject.toml',
    'Cargo.toml',
    'pom.xml',
    'build.gradle',
    'Dockerfile',
    'docker-compose.yml',
    'serverless.yml',
    'app.yaml',
    '.csproj',
    '.fsproj'
  ];

  // Maximum file size to read (1MB)
  private readonly maxFileSize = 1024 * 1024;

  // Maximum depth to traverse in directories
  private readonly maxTraversalDepth = 4;

  // AI client for workspace profiling
  private aiClient: AIClient;

  constructor(
    private readonly workspaceFolder: vscode.WorkspaceFolder,
    private readonly settingsManager?: SettingsManager
  ) {
    // Initialize AI client
    if (this.settingsManager) {
      const selectedModel = this.settingsManager.getSelectedAIModel();
      this.aiClient = AIClientFactory.getClient(selectedModel);
    } else {
      // Default to Claude if settings manager is not provided
      this.aiClient = AIClientFactory.getClient('claude-3-5-sonnet-20241022');
    }
  }

  /**
   * Profile the workspace and detect application types
   */
  public async profileWorkspace(secretApiKey: string,progressCallback?: (message: string) => void): Promise<ApplicationProfile[]> {
    try {
      // First collect the project structure
      progressCallback?.('Collecting project structure...');
      const projectStructure = await this.collectProjectStructure(progressCallback);

      // Next, read critical files for deeper analysis
      progressCallback?.('Analyzing key project files...');
      const keyFileContents = await this.readKeyProjectFiles(projectStructure);

      // Use AI to determine the project type
      progressCallback?.('Determining project type...');
      const applicationProfiles = await this.determineProjectTypes(projectStructure, keyFileContents, secretApiKey, progressCallback);

      return applicationProfiles;
    } catch (error) {
      console.error('Error profiling workspace:', error);
      throw error;
    }
  }

  /**
   * Collect the basic project structure (directories and files)
   */
  private async collectProjectStructure(progressCallback?: (message: string) => void): Promise<any> {
    const rootPath = this.workspaceFolder.uri.fsPath;
    progressCallback?.(`Scanning project structure at: ${rootPath}`);
    const structure: any = {
      rootPath,
      directories: [],
      files: []
    };

    await this.traverseDirectory(rootPath, structure, 0);

    // Return the collected structure
    if (progressCallback) {
      progressCallback(`Project structure collected with ${structure.directories.length} directories and ${structure.files.length} files.`);
    }
    return structure;
  }

  /**
   * Recursively traverse the directory to build the project structure
   */
  private async traverseDirectory(dirPath: string, structure: any, depth: number): Promise<void> {
    if (depth > this.maxTraversalDepth) {
      return;
    }

    try {
      const entries = fs.readdirSync(dirPath, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dirPath, entry.name);
        const relativePath = path.relative(this.workspaceFolder.uri.fsPath, fullPath);

        // Skip auto-generated files and directories
        if (this.shouldSkip(entry.name, relativePath)) {
          continue;
        }

        if (entry.isDirectory()) {
          structure.directories.push({
            name: entry.name,
            path: relativePath,
            depth
          });
          
          // Recursively traverse subdirectories
          await this.traverseDirectory(fullPath, structure, depth + 1);
        } else if (entry.isFile()) {
          structure.files.push({
            name: entry.name,
            path: relativePath,
            extension: path.extname(entry.name).toLowerCase(),
            size: fs.statSync(fullPath).size
          });
        }
      }
    } catch (error) {
      console.error(`Error traversing directory ${dirPath}:`, error);
    }
  }

  /**
   * Check if a file or directory should be skipped
   */
  private shouldSkip(name: string, relativePath: string): boolean {
    // Check if it matches any auto-generated patterns
    for (const pattern of this.autoGeneratedFilePatterns) {
      if (pattern.startsWith('*.')) {
        // Extension pattern
        const ext = pattern.substring(1);
        if (name.endsWith(ext)) {
          return true;
        }
      } else if (name === pattern || relativePath.includes(pattern)) {
        return true;
      }
    }
    
    return false;
  }

  /**
   * Read contents of key project files for deeper analysis
   */
  private async readKeyProjectFiles(projectStructure: any): Promise<any[]> {
    const keyFiles: any[] = [];
    
    for (const file of projectStructure.files) {
      if (this.isKeyProjectFile(file.name)) {
        try {
          const fullPath = path.join(this.workspaceFolder.uri.fsPath, file.path);
          const stats = fs.statSync(fullPath);
          
          // Skip files that are too large
          if (stats.size > this.maxFileSize) {
            keyFiles.push({
              name: file.name,
              path: file.path,
              content: '[File too large to include]'
            });
            continue;
          }
          
          const content = fs.readFileSync(fullPath, 'utf8');
          keyFiles.push({
            name: file.name,
            path: file.path,
            content
          });
        } catch (error) {
          console.error(`Error reading file ${file.path}:`, error);
        }
      }
    }
    
    return keyFiles;
  }

  /**
   * Check if a file is a key project file
   */
  private isKeyProjectFile(fileName: string): boolean {
    return this.projectSignalFiles.includes(fileName);
  }

  /**
   * Use AI to determine the project types based on structure and key files
   */
  private async determineProjectTypes(
    projectStructure: any,
    keyFileContents: any[],
    secretApiKey: string,
    progressCallback?: (message: string) => void,
  ): Promise<ApplicationProfile[]> {
    try {
      // Create a condensed representation of the project
      const projectData = {
        structure: {
          directories: projectStructure.directories.map((dir: any) => ({
            name: dir.name,
            path: dir.path,
            depth: dir.depth
          })),
          files: projectStructure.files.map((file: any) => ({
            name: file.name,
            path: file.path,
            extension: file.extension
          }))
        },
        keyFiles: keyFileContents
      };

      // Load the app profiler prompt
      let promptTemplate = '';
      try {
        promptTemplate = await loadPrompt('common/app-profiler.txt');
      } catch (error) {
        console.error('Error loading app profiler prompt:', error);
        // Fallback to a basic prompt if the file can't be loaded
        promptTemplate = `You are an expert application profiler. Analyze the following project structure and key file contents to determine the type of application(s).`;
      }

      // Create a prompt for the AI
      const prompt = `
      ${promptTemplate}
      
      PROJECT STRUCTURE:
      ${JSON.stringify(projectData, null, 2)}
      
      Based on this information, determine:
      1. The type of application(s) in this workspace
      2. If it's a monorepo, identify each distinct application
      3. The primary programming languages and frameworks used
      4. For each identified application, provide category, subcategory, and technology
      
      Respond in the following JSON format:
      {
        "applications": [
          {
            "name": "application name",
            "path": "relative/path/to/app",
            "category": "category",
            "subcategory": "subcategory",
            "technology": "specific technology",
            "confidence": confidence percentage,
            "languages": ["language1", "language2"],
            "frameworks": ["framework1", "framework2"],
            "buildTools": ["tool1", "tool2"],
            "evidence": ["reason1", "reason2"]
          }
        ]
      }
      `;

      progressCallback?.('Sending request to AI service...');

      try {
        // Call the AI client to analyze the workspace
        const response = await this.aiClient.sendRequest(prompt, {
          temperature: 0, // Lower temperature for more deterministic results
          maxTokens: 2048,  // Ensure enough tokens for the response
          apiKey: secretApiKey // The API key should be managed by the client
        });
        
        // Parse the JSON response
        try {
          // Extract the JSON part from the response
          const jsonMatch = response.content.match(/\{[\s\S]*\}/);
          if (!jsonMatch) {
            console.error('No JSON found in response:', response.content);
            return []; // Fallback to empty array
          }
          
          const jsonContent = jsonMatch[0];
          const result = JSON.parse(jsonContent);
          
          if (!result.applications || !Array.isArray(result.applications)) {
            console.error('Invalid response format, missing applications array:', result);
            return []; // Fallback to empty array
          }
          
          return result.applications;
        } catch (parseError) {
          console.error('Error parsing AI response:', parseError);
          console.error('Response content:', response.content);
          return []; // Fallback to empty array
        }
      } catch (aiError) {
        console.error('Error calling AI service:', aiError);
        return []; // Fallback to empty array
      }
    } catch (error) {
      console.error('Error determining project types:', error);
      throw error;
    }
  }
}

export default ProjectProfiler;
