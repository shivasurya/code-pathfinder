#!/usr/bin/env node

/**
 * Model Configuration Generator
 * 
 * This script reads models.json and generates:
 * 1. TypeScript type definitions
 * 2. JavaScript type definitions (JSDoc)
 * 3. Runtime configuration module
 * 4. Updates package.json with model enums
 * 
 * Usage: node scripts/generate-model-config.js
 */

const fs = require('fs');
const path = require('path');

// Paths
const MODELS_JSON_PATH = path.join(__dirname, '../config/models.json');
const GENERATED_DIR = path.join(__dirname, '../lib/generated');
const PACKAGE_JSON_PATH = path.join(__dirname, '../../../package.json');

// Ensure generated directory exists
if (!fs.existsSync(GENERATED_DIR)) {
  fs.mkdirSync(GENERATED_DIR, { recursive: true });
}

// Read models configuration
const modelsConfig = JSON.parse(fs.readFileSync(MODELS_JSON_PATH, 'utf8'));
const models = modelsConfig.models;

// Filter active models (not deprecated)
const activeModels = models.filter(m => m.status === 'available');

console.log('🚀 Generating model configuration files...\n');

// ============================================================================
// 1. Generate TypeScript Type Definitions
// ============================================================================
function generateTypeScriptTypes() {
  const modelIds = activeModels.map(m => `  | '${m.id}'`).join('\n');
  
  const content = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by scripts/generate-model-config.js from config/models.json
 * Last updated: ${new Date().toISOString()}
 */

export type AIModel =
${modelIds};

export interface ModelConfig {
  id: AIModel;
  provider: 'openai' | 'anthropic' | 'google' | 'xai' | 'ollama';
  client: string;
  displayName: string;
  description: string;
  year: number;
  contextWindow: number;
  contextWindowBeta?: number;
  maxOutput: number;
  status: 'available' | 'deprecated';
  recommended: boolean;
  order: number;
}

export interface ProviderInfo {
  name: string;
  apiKeyEnvVar: string | null;
}
`;

  const outputPath = path.join(GENERATED_DIR, 'model-types.d.ts');
  fs.writeFileSync(outputPath, content, 'utf8');
  console.log('✅ Generated:', outputPath);
}

// ============================================================================
// 2. Generate JavaScript Type Definitions (JSDoc)
// ============================================================================
function generateJavaScriptTypes() {
  const modelIds = activeModels.map(m => `'${m.id}'`).join(' | ');
  
  const content = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by scripts/generate-model-config.js from config/models.json
 * Last updated: ${new Date().toISOString()}
 */

/**
 * @typedef {${modelIds}} AIModel
 */

/**
 * @typedef {Object} ModelConfig
 * @property {AIModel} id
 * @property {'openai' | 'anthropic' | 'google' | 'xai' | 'ollama'} provider
 * @property {string} client
 * @property {string} displayName
 * @property {string} description
 * @property {number} year
 * @property {number} contextWindow
 * @property {number} [contextWindowBeta]
 * @property {number} maxOutput
 * @property {'available' | 'deprecated'} status
 * @property {boolean} recommended
 * @property {number} order
 */

/**
 * @typedef {Object} ProviderInfo
 * @property {string} name
 * @property {string | null} apiKeyEnvVar
 */

module.exports = {};
`;

  const outputPath = path.join(GENERATED_DIR, 'model-types.js');
  fs.writeFileSync(outputPath, content, 'utf8');
  console.log('✅ Generated:', outputPath);
}

// ============================================================================
// 3. Generate Runtime Configuration Module
// ============================================================================
function generateRuntimeConfig() {
  const modelsArray = JSON.stringify(models, null, 2);
  const providerInfo = JSON.stringify(modelsConfig.providerInfo, null, 2);
  
  const content = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by scripts/generate-model-config.js from config/models.json
 * Last updated: ${new Date().toISOString()}
 */

const MODELS = ${modelsArray};

const PROVIDER_INFO = ${providerInfo};

/**
 * Model configuration manager
 */
class ModelConfig {
  /**
   * Get configuration for a specific model
   * @param {string} modelId - The model ID
   * @returns {Object | undefined} Model configuration
   */
  static get(modelId) {
    return MODELS.find(m => m.id === modelId);
  }

  /**
   * Get all active (non-deprecated) models
   * @returns {Array} Array of active model configurations
   */
  static getAllActive() {
    return MODELS.filter(m => m.status === 'available').sort((a, b) => a.order - b.order);
  }

  /**
   * Get all models (including deprecated)
   * @returns {Array} Array of all model configurations
   */
  static getAll() {
    return [...MODELS];
  }

  /**
   * Get models by provider
   * @param {string} provider - Provider name (openai, anthropic, google, xai, ollama)
   * @returns {Array} Array of model configurations for the provider
   */
  static getByProvider(provider) {
    return MODELS.filter(m => m.provider === provider);
  }

  /**
   * Get provider information
   * @param {string} provider - Provider name
   * @returns {Object | undefined} Provider information
   */
  static getProviderInfo(provider) {
    return PROVIDER_INFO[provider];
  }

  /**
   * Get recommended models
   * @returns {Array} Array of recommended model configurations
   */
  static getRecommended() {
    return MODELS.filter(m => m.recommended && m.status === 'available');
  }

  /**
   * Get client class name for a model
   * @param {string} modelId - The model ID
   * @returns {string | undefined} Client class name
   */
  static getClient(modelId) {
    const model = this.get(modelId);
    return model?.client;
  }

  /**
   * Get display name for a model
   * @param {string} modelId - The model ID
   * @returns {string} Display name or model ID if not found
   */
  static getDisplayName(modelId) {
    const model = this.get(modelId);
    return model?.displayName || modelId;
  }

  /**
   * Get provider name for a model
   * @param {string} modelId - The model ID
   * @returns {string | undefined} Provider name
   */
  static getProvider(modelId) {
    const model = this.get(modelId);
    if (!model) return undefined;
    return PROVIDER_INFO[model.provider]?.name;
  }
}

module.exports = {
  ModelConfig,
  MODELS,
  PROVIDER_INFO
};
`;

  const outputPath = path.join(GENERATED_DIR, 'model-config.js');
  fs.writeFileSync(outputPath, content, 'utf8');
  console.log('✅ Generated:', outputPath);
}

// ============================================================================
// 4. Generate TypeScript Configuration for VS Code Extension
// ============================================================================
function generateExtensionConfig() {
  const modelsArray = JSON.stringify(models, null, 2);
  const providerInfo = JSON.stringify(modelsConfig.providerInfo, null, 2);
  const modelIds = activeModels.map(m => `  | '${m.id}'`).join('\n');
  
  const content = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by scripts/generate-model-config.js from config/models.json
 * Last updated: ${new Date().toISOString()}
 */

export type AIModel =
${modelIds};

export interface ModelConfigType {
  id: AIModel;
  provider: 'openai' | 'anthropic' | 'google' | 'xai' | 'ollama';
  client: string;
  displayName: string;
  description: string;
  year: number;
  contextWindow: number;
  contextWindowBeta?: number;
  maxOutput: number;
  status: 'available' | 'deprecated';
  recommended: boolean;
  order: number;
}

const MODELS: ModelConfigType[] = ${modelsArray};

const PROVIDER_INFO = ${providerInfo};

/**
 * Model configuration manager for VS Code extension
 */
export class ModelConfig {
  /**
   * Get configuration for a specific model
   */
  static get(modelId: string) {
    return MODELS.find(m => m.id === modelId);
  }

  /**
   * Get all active (non-deprecated) models
   */
  static getAllActive() {
    return MODELS.filter(m => m.status === 'available').sort((a, b) => a.order - b.order);
  }

  /**
   * Get all models (including deprecated)
   */
  static getAll() {
    return [...MODELS];
  }

  /**
   * Get models by provider
   */
  static getByProvider(provider: string) {
    return MODELS.filter(m => m.provider === provider);
  }

  /**
   * Get provider information
   */
  static getProviderInfo(provider: string) {
    return PROVIDER_INFO[provider];
  }

  /**
   * Get recommended models
   */
  static getRecommended() {
    return MODELS.filter(m => m.recommended && m.status === 'available');
  }

  /**
   * Get client class name for a model
   */
  static getClient(modelId: string) {
    const model = this.get(modelId);
    return model?.client;
  }

  /**
   * Get display name for a model
   */
  static getDisplayName(modelId: string) {
    const model = this.get(modelId);
    return model?.displayName || modelId;
  }

  /**
   * Get provider name for a model
   */
  static getProvider(modelId: string) {
    const model = this.get(modelId);
    if (!model) return undefined;
    return PROVIDER_INFO[model.provider]?.name;
  }
}
`;

  const extensionGeneratedDir = path.join(__dirname, '../../../src/generated');
  if (!fs.existsSync(extensionGeneratedDir)) {
    fs.mkdirSync(extensionGeneratedDir, { recursive: true });
  }

  const outputPath = path.join(extensionGeneratedDir, 'model-config.ts');
  fs.writeFileSync(outputPath, content, 'utf8');
  console.log('✅ Generated:', outputPath);
}

// ============================================================================
// 5. Update package.json
// ============================================================================
function updatePackageJson() {
  const packageJson = JSON.parse(fs.readFileSync(PACKAGE_JSON_PATH, 'utf8'));
  
  // Get model IDs and descriptions
  const enumValues = activeModels.map(m => m.id);
  const enumDescriptions = activeModels.map(m => {
    const providerName = modelsConfig.providerInfo[m.provider]?.name || m.provider;
    return `${providerName} ${m.displayName} (${m.year}) - ${m.description}`;
  });

  // Update the configuration
  if (packageJson.contributes && packageJson.contributes.configuration && 
      packageJson.contributes.configuration.properties) {
    
    const aiModelConfig = packageJson.contributes.configuration.properties['secureflow.AIModel'];
    if (aiModelConfig) {
      aiModelConfig.enum = enumValues;
      aiModelConfig.enumDescriptions = enumDescriptions;
      
      // Update default to recommended model
      const recommended = models.find(m => m.recommended);
      if (recommended) {
        aiModelConfig.default = recommended.id;
      }
    }
  }

  fs.writeFileSync(PACKAGE_JSON_PATH, JSON.stringify(packageJson, null, 2) + '\n', 'utf8');
  console.log('✅ Updated:', PACKAGE_JSON_PATH);
}

// ============================================================================
// Main Execution
// ============================================================================
try {
  generateTypeScriptTypes();
  generateJavaScriptTypes();
  generateRuntimeConfig();
  generateExtensionConfig();
  updatePackageJson();
  
  console.log('\n✨ All model configuration files generated successfully!');
  console.log(`\n📊 Summary:`);
  console.log(`   - Total models: ${models.length}`);
  console.log(`   - Active models: ${activeModels.length}`);
  console.log(`   - Providers: ${Object.keys(modelsConfig.providerInfo).join(', ')}`);
  console.log(`   - Recommended: ${models.filter(m => m.recommended).map(m => m.displayName).join(', ')}`);
  
} catch (error) {
  console.error('❌ Error generating model configuration:', error);
  process.exit(1);
}
