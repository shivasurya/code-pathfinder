const fs = require('fs');
const path = require('path');
const { WorkspaceAnalyzer, ApplicationProfile } = require('../lib/workspace-analyzer');

/**
 * CLI-friendly project profiler that analyzes workspace structure
 * and determines application types without VS Code dependencies
 */
class CLIProjectProfiler {
  constructor(options = {}) {
    // Files that would signal automatic generation (to be skipped)
    this.autoGeneratedFilePatterns = [
      '.git',
      'node_modules',
      'dist',
      'build',
      '.next',
      '.cache',
      'coverage',
      '__pycache__',
      '*.min.js',
      '*.min.css',
      '*.lock',
      'package-lock.json',
      'yarn.lock',
      'pnpm-lock.yaml'
    ];

    // Key project files that provide strong signals about project type
    this.projectSignalFiles = [
      'package.json',
      'tsconfig.json',
      'angular.json',
      'next.config.js',
      'nuxt.config.js',
      'vite.config.js',
      'webpack.config.js',
      'AndroidManifest.xml',
      'Info.plist',
      'Podfile',
      'pubspec.yaml',
      'setup.py',
      'requirements.txt',
      'pyproject.toml',
      'Cargo.toml',
      'pom.xml',
      'build.gradle',
      'Dockerfile',
      'docker-compose.yml',
      'serverless.yml',
      'app.yaml',
      '.csproj',
      '.fsproj'
    ];

    // Maximum file size to read (1MB)
    this.maxFileSize = 1024 * 1024;

    // Maximum depth to traverse in directories
    this.maxTraversalDepth = 4;

    // Initialize workspace analyzer
    const selectedModel = options.selectedModel || 'claude-sonnet-4-5-20250929';
    this.workspaceAnalyzer = new WorkspaceAnalyzer({ selectedModel });
  }

  /**
   * Profile the workspace and detect application types
   * @param {string} projectPath - Root path of the project to analyze
   * @param {string} secretApiKey - API key for AI service
   * @param {Function} progressCallback - Optional progress callback
   * @returns {Promise<ApplicationProfile[]>} Array of detected application profiles
   */
  async profileWorkspace(projectPath, secretApiKey, progressCallback) {
    try {
      // Validate project path
      if (!fs.existsSync(projectPath)) {
        throw new Error(`Project path does not exist: ${projectPath}`);
      }

      const stats = fs.statSync(projectPath);
      if (!stats.isDirectory()) {
        throw new Error(`Project path is not a directory: ${projectPath}`);
      }

      // First collect the project structure
      progressCallback?.('Collecting project structure...');
      const projectStructure = await this.collectProjectStructure(
        projectPath,
        progressCallback
      );

      // Next, read critical files for deeper analysis
      progressCallback?.('Analyzing key project files...');
      const keyFileContents = await this.readKeyProjectFiles(
        projectPath,
        projectStructure
      );

      // Use AI to determine the project type
      progressCallback?.('Determining project type...');
      const applicationProfiles = await this.workspaceAnalyzer.determineProjectTypes(
        projectStructure,
        keyFileContents,
        secretApiKey,
        progressCallback
      );

      return applicationProfiles;
    } catch (error) {
      console.error('Error profiling workspace:', error);
      throw error;
    }
  }

  /**
   * Collect the basic project structure (directories and files)
   * @param {string} rootPath - Root path to analyze
   * @param {Function} progressCallback - Optional progress callback
   * @returns {Promise<Object>} Project structure object
   */
  async collectProjectStructure(rootPath, progressCallback) {
    progressCallback?.(`Scanning project structure at: ${rootPath}`);
    const structure = {
      rootPath,
      directories: [],
      files: []
    };

    await this.traverseDirectory(rootPath, structure, 0, rootPath);

    // Return the collected structure
    if (progressCallback) {
      progressCallback(
        `Project structure collected with ${structure.directories.length} directories and ${structure.files.length} files.`
      );
    }
    return structure;
  }

  /**
   * Recursively traverse the directory to build the project structure
   * @param {string} dirPath - Current directory path
   * @param {Object} structure - Structure object to populate
   * @param {number} depth - Current traversal depth
   * @param {string} rootPath - Root path for relative path calculation
   */
  async traverseDirectory(dirPath, structure, depth, rootPath) {
    if (depth > this.maxTraversalDepth) {
      return;
    }

    try {
      const entries = fs.readdirSync(dirPath, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dirPath, entry.name);
        const relativePath = path.relative(rootPath, fullPath);

        // Skip auto-generated files and directories
        if (this.shouldSkip(entry.name, relativePath)) {
          continue;
        }

        if (entry.isDirectory()) {
          structure.directories.push({
            name: entry.name,
            path: relativePath,
            depth
          });

          // Recursively traverse subdirectories
          await this.traverseDirectory(fullPath, structure, depth + 1, rootPath);
        } else if (entry.isFile()) {
          const stats = fs.statSync(fullPath);
          structure.files.push({
            name: entry.name,
            path: relativePath,
            extension: path.extname(entry.name).toLowerCase(),
            size: stats.size
          });
        }
      }
    } catch (error) {
      console.error(`Error traversing directory ${dirPath}:`, error);
    }
  }

  /**
   * Check if a file or directory should be skipped
   * @param {string} name - File or directory name
   * @param {string} relativePath - Relative path from root
   * @returns {boolean} True if should be skipped
   */
  shouldSkip(name, relativePath) {
    // Check if it matches any auto-generated patterns
    for (const pattern of this.autoGeneratedFilePatterns) {
      if (pattern.startsWith('*.')) {
        // Extension pattern
        const ext = pattern.substring(1);
        if (name.endsWith(ext)) {
          return true;
        }
      } else if (name === pattern || relativePath.includes(pattern)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Read contents of key project files for deeper analysis
   * @param {string} rootPath - Root path of the project
   * @param {Object} projectStructure - Project structure object
   * @returns {Promise<Array>} Array of key file contents
   */
  async readKeyProjectFiles(rootPath, projectStructure) {
    const keyFiles = [];

    for (const file of projectStructure.files) {
      if (this.isKeyProjectFile(file.name)) {
        try {
          const fullPath = path.join(rootPath, file.path);
          const stats = fs.statSync(fullPath);

          // Skip files that are too large
          if (stats.size > this.maxFileSize) {
            keyFiles.push({
              name: file.name,
              path: file.path,
              content: '[File too large to include]'
            });
            continue;
          }

          const content = fs.readFileSync(fullPath, 'utf8');
          keyFiles.push({
            name: file.name,
            path: file.path,
            content
          });
        } catch (error) {
          console.error(`Error reading file ${file.path}:`, error);
        }
      }
    }

    return keyFiles;
  }

  /**
   * Check if a file is a key project file
   * @param {string} fileName - Name of the file
   * @returns {boolean} True if it's a key project file
   */
  isKeyProjectFile(fileName) {
    return this.projectSignalFiles.includes(fileName);
  }

  /**
   * Set the AI model to use for analysis
   * @param {string} modelName - Name of the AI model
   */
  setModel(modelName) {
    this.workspaceAnalyzer.setModel(modelName);
  }

  /**
   * Get token usage statistics
   */
  getTokenUsage() {
    return this.workspaceAnalyzer.getTokenUsage();
  }

  /**
   * Display final token usage summary
   */
  displayTokenSummary() {
    this.workspaceAnalyzer.displayTokenSummary();
  }
}

module.exports = {
  CLIProjectProfiler,
  ApplicationProfile
};
