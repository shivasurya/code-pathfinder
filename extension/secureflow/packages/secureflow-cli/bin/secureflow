#!/usr/bin/env node

/*
 * SecureFlow CLI (scaffold)
 * This is a minimal, non-breaking CLI entry that will evolve to reuse extension logic via adapters.
 */

const { Command } = require('commander');
const { yellow, red, cyan } = require('colorette');
const pkg = require('../package.json');
const { getMaskedConfig, loadConfig, CONFIG_FILE } = require('../lib/config');
const { CLIProfileCommand } = require('../profiler');
const { CLIFullScanCommand } = require('../scanner');
const { AnalyticsService } = require('../lib/services/analytics');

// Initialize analytics for CLI
const analytics = AnalyticsService.getInstance();

// Main async function to ensure proper initialization order
async function main() {
  // Initialize analytics FIRST and wait for it (silently)
  try {
    await analytics.initializeForCLI({
      cli_version: pkg.version
    });
  } catch (err) {
    // Silently fail - analytics should not disrupt CLI
  }

  // NOW set up the program after analytics is ready
  const program = new Command();

  program
    .name('secureflow')
    .description('AI-powered security analysis CLI tool with intelligent file discovery')
    .version(pkg.version);

  program
    .command('scan')
    .description('Perform full security scan of project using AI analysis')
    .argument('[path]', 'Path to project directory (defaults to current directory)', '.')
    .option('--model <model>', 'AI model to use for analysis')
    .option('--format <format>', 'Output format: text|json|defectdojo', 'text')
    .option('--output <file>', 'Save results to file')
    .option('--defectdojo', 'Export results in DefectDojo import format (same as --format defectdojo)')
    .option('--defectdojo-url <url>', 'DefectDojo instance URL (e.g., https://defectdojo.example.com)')
    .option('--defectdojo-token <token>', 'DefectDojo API token for authentication')
    .option('--defectdojo-product-id <id>', 'DefectDojo product ID to submit findings to')
    .option('--defectdojo-engagement-id <id>', 'DefectDojo engagement ID (optional - will create if not provided)')
    .option('--defectdojo-test-title <title>', 'Title for the DefectDojo test (defaults to "SecureFlow Scan")')
    .action(async (projectPath, options) => {
    try {
      // Track scan command usage
      await analytics.trackEvent('CLI Command: Scan', {
        ai_model: options.model || 'default',
        output_format: options.format || 'text',
        has_defectdojo: !!options.defectdojo
      });

      // Handle --defectdojo flag
      let outputFormat = options.format;
      if (options.defectdojo) {
        outputFormat = 'defectdojo';
      }
      
      const scanCommand = new CLIFullScanCommand({
        selectedModel: options.model,
        outputFormat: outputFormat,
        outputFile: options.output,
        defectDojoOptions: {
          url: options.defectdojoUrl,
          token: options.defectdojoToken,
          productId: options.defectdojoProductId,
          engagementId: options.defectdojoEngagementId,
          testTitle: options.defectdojoTestTitle || 'SecureFlow Scan'
        }
      });
      await scanCommand.execute(projectPath, options);
    } catch (error) {
      console.error(red('❌ Full scan failed:'));
      console.error(error.message);
      if (process.env.DEBUG) {
        console.error(error.stack);
      }
      process.exit(1);
    }
  });

  program
    .command('profile')
    .description('Profile project to identify application types and technologies')
    .argument('[path]', 'Path to project directory (defaults to current directory)', '.')
    .option('--model <model>', 'AI model to use for analysis')
    .option('--format <format>', 'Output format: text|json', 'text')
    .option('--output <file>', 'Save results to file')
    .action(async (projectPath, options) => {
    try {
      // Track profile command usage
      await analytics.trackEvent('CLI Command: Profile', {
        ai_model: options.model || 'default',
        output_format: options.format || 'text'
      });

      const profileCommand = new CLIProfileCommand({
        selectedModel: options.model
      });
      await profileCommand.execute(projectPath, options);
    } catch (error) {
      console.error(red('❌ Profile command failed:'));
      console.error(error.message);
      if (process.env.DEBUG) {
        console.error(error.stack);
      }
      process.exit(1);
    }
  });

  program
    .command('config')
    .description('Show CLI configuration (masked by default)')
    .option('--show', 'Show configuration summary', false)
    .option('--raw', 'Do not mask secrets (use with caution)', false)
    .action((opts) => {
    if (!opts.show) {
      console.log('Use --show to display the configuration.');
      console.log(`Config file path: ${CONFIG_FILE}`);
      process.exitCode = 0;
      return;
    }

    const cfg = opts.raw ? loadConfig() : getMaskedConfig();
    console.log(cyan('SecureFlow CLI configuration'));
    console.log(JSON.stringify(cfg, null, 2));
    process.exitCode = 0;
  });

  program
    .command('helpall')
    .description('Show help for all commands')
    .action(async () => {
      // Track help command usage
      await analytics.trackEvent('CLI Command: Help', {});
      program.commands.forEach((c) => c.outputHelp());
    });

  // Parse CLI arguments
  await program.parseAsync(process.argv);
  
  // Shutdown analytics after command completes
  await analytics.shutdown();
}

// Run the main function
main().catch((err) => {
  console.error(red('[secureflow] fatal error'));
  console.error(err?.stack || err?.message || String(err));
  process.exit(1);
});
